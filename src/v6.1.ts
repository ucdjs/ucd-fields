// This file is generated by ucd codegen. Do not edit this file directly.
// Unicode Version: 6.1

//#region data-files/v6.1.0/ArabicShaping.txt
/**
 * This interface represents the data structure for Arabic shaping properties.
 */
export interface ArabicShaping {
    /**
     * The code point, in 4-digit hexadecimal form, of an Arabic, Syriac, N'Ko, or Mandaic character.
     * Example: '0629'
     */
    code_point: string;

    /**
     * A short schematic name for that character, descriptive of the shape.
     * Example: 'TEH MARBUTA'
     */
    schematic_name: string;

    /**
     * Defines the joining type of the character.
     * Possible values: "R", "L", "D", "C", "U", "T"
     * Example: 'R' for Right_Joining
     */
    joining_type: "R" | "L" | "D" | "C" | "U" | "T";

    /**
     * Defines the joining group of the character, based on schematic character names.
     * Example: 'TEH MARBUTA' corresponds to [Joining_Group = Teh_Marbuta]
     */
    joining_group: string;
}

export const ARABIC_SHAPING_FIELDS = [
    "code_point",
    "schematic_name",
    "joining_type",
    "joining_group"
];
//#endregion

//#region data-files/v6.1.0/BidiMirroring.txt
/**
 * Interface representing the Bidi_Mirroring_Glyph property data.
 */
export interface BidiMirroring {
    /**
     * The code point of the original character represented as a hexadecimal value.
     * Example: '0041' for 'A'.
     */
    original_code_point: string;

    /**
     * The code point of the mirrored character represented as a hexadecimal value.
     * Example: '0061' for 'a'.
     */
    mirrored_code_point: string;

    /**
     * Indicates if the mirroring is a best fit.
     * Example: true if the mapping is a best fit mirroring.
     */
    best_fit: boolean;
}

export const BIDI_MIRRORING_FIELDS = [
    "original_code_point",
    "mirrored_code_point",
    "best_fit"
];
//#endregion

//#region data-files/v6.1.0/BidiTest.txt
/**
 * This interface represents the structure of the BidiTest data.
 */
export interface BidiTest {
    /**
     * An ordered space-delimited list of numbers indicating the resulting levels
     * for each input property value. The UBA does not assign levels to certain values;
     * those are indicated with an 'x'.
     * 
     * Example:
     *   @Levels:    1 0
     *   @Levels:    x 1 x 2
     */
    levels: string;

    /**
     * An ordered space-delimited list of numbers indicating the resulting
     * visual ordering from left to right. The numbers are zero-based, and
     * are indexes into the input string. Items with a level of 'x' are skipped.
     * 
     * Example:
     *   @Reorder:    1 0
     *   @Reorder:    3 1
     */
    reorder: string;

    /**
     * An ordered list of BIDI property values.
     */
    input: string;

    /**
     * A hex bitset for paragraph levels (P): 1 = auto-LTR, 2 = LTR, 4 = RTL.
     * Auto-LTR (standard BIDI) uses the first L/R/AL character, and is LTR if none is found.
     * 
     * Example:
     *    L LRE R R; 7
     *    L LRE R AL; 7
     */
    bitset: string;
}

export const BIDI_TEST_FIELDS = ["levels", "reorder", "input", "bitset"];
//#endregion

//#region data-files/v6.1.0/Blocks.txt
/**
 * Interface representing Unicode Character Database blocks.
 */
export interface Blocks {
    /**
     * The starting code point of the block.
     * Format: U+XXXX (e.g., U+0041 for 'A')
     */
    start_code: string;

    /**
     * The ending code point of the block.
     * Format: U+XXXX (e.g., U+007A for 'z')
     */
    end_code: string;

    /**
     * The name of the block.
     * Example: "Basic Latin"
     */
    block_name: string;
}

export const BLOCKS_FIELDS = [
    "start_code",
    "end_code",
    "block_name"
];
//#endregion

//#region data-files/v6.1.0/CJKRadicals.txt
/**
 * Interface representing the mapping from radical numbers to characters in the CJK Radical block and CJK Radicals Supplement block.
 */
export interface CJKRadicals {
    /**
     * The radical number, which matches the regular expression [0-9]{1,3}?' and can end with an apostrophe.
     */
    radical_number: string;

    /**
     * The CJK Radical character corresponding to the radical number.
     */
    cjk_radical_character: string;

    /**
     * The CJK Unified Ideograph formed from the radical only.
     */
    cjk_unified_ideograph: string;
}

export const CJK_RADICALS_FIELDS = [
    "radical_number",
    "cjk_radical_character",
    "cjk_unified_ideograph"
];
//#endregion

//#region data-files/v6.1.0/CaseFolding.txt
/**
 * This interface represents the case folding properties as defined in the Unicode Character Database.
 */
export interface CaseFolding {
    /**
     * The Unicode code point of the character.
     * Format: Hexadecimal (e.g., U+0041 for 'A').
     */
    code: string;

    /**
     * The status of the case folding mapping.
     * Possible values: "C" (common), "F" (full), "S" (simple), "T" (Turkic special case).
     */
    status: "C" | "F" | "S" | "T";

    /**
     * The mapping for the case folding.
     * Format: A single character or multiple characters separated by spaces.
     * Example: "a" for simple case folding, "Ã¤ a" for full case folding.
     */
    mapping: string;

    /**
     * The name of the character.
     * This is a descriptive name for the character represented by the code point.
     */
    name: string;
}

export const CASE_FOLDING_FIELDS = [
    "code",
    "status",
    "mapping",
    "name"
];
//#endregion

//#region data-files/v6.1.0/CompositionExclusions.txt
/**
 * This interface represents the Composition Exclusion Table defined in UAX #15, Unicode Normalization Forms.
 * It includes characters that are excluded from composition according to the Unicode standard.
 */
export interface CompositionExclusions {
    /**
     * The character that is excluded from composition.
     * Example: '\u002D' for hyphen.
     */
    excluded_character: string;
    /**
     * The reason for exclusion from composition.
     * Example: 'Compatibility' or 'Canonical'.
     */
    exclusion_reason: "Compatibility" | "Canonical";
}

export const COMPOSITION_EXCLUSIONS_FIELDS = [
    "excluded_character",
    "exclusion_reason"
];
//#endregion

//#region data-files/v6.1.0/DerivedAge.txt
/**
 * This interface represents the derived properties of Unicode characters, detailing when various code points were first assigned in Unicode.
 */
export interface DerivedAge {
    /**
     * The date when the code point was assigned.
     * Format: YYYY-MM-DD HH:MM:SS GMT
     * Example: "2012-01-20 21:47:00 GMT"
     */
    assigned_date: string;

    /**
     * The version of Unicode in which the code point was assigned.
     * Format: Major.Minor.Patch
     * Example: "6.1.0"
     */
    unicode_version: string;

    /**
     * Indicates the type of code point assigned.
     * Possible values: "graphic", "format", "control", "private-use", "surrogate", "noncharacter"
     */
    code_point_type: "graphic" | "format" | "control" | "private-use" | "surrogate" | "noncharacter";

    /**
     * Additional notes regarding the assignment of the code point.
     * Example: "The term 'assigned' means that a previously reserved code point was assigned to be a character."
     */
    notes: string;
}

export const DERIVED_AGE_FIELDS = [
    "assigned_date",
    "unicode_version",
    "code_point_type",
    "notes"
];
//#endregion

//#region data-files/v6.1.0/DerivedCoreProperties.txt
/**
 * Interface representing the derived core properties from the Unicode Character Database.
 */
export interface DerivedCoreProperties {
    /**
     * The Unicode character's general category.
     * Example: "Lu" for uppercase letter.
     */
    general_category: "Lu" | "Ll" | "Lt" | "Lm" | "Lo" | "Mn" | "Mc" | "Me" | "Nd" | "Nl" | "No" | "Pc" | "Pd" | "Ps" | "Pe" | "Pi" | "Pf" | "Po" | "Sm" | "Sc" | "Sk" | "So" | "Zs" | "Zl" | "Zp";

    /**
     * The Unicode character's script.
     * Example: "Latn" for Latin script.
     */
    script: string;

    /**
     * The Unicode character's numeric value, if applicable.
     * Example: "1.5" for a numeric character.
     */
    numeric_value: string | null;

    /**
     * The Unicode character's bidirectional category.
     * Example: "L" for left-to-right.
     */
    bidi_category: "L" | "R" | "AL" | "EN" | "ES" | "ET" | "AN" | "CS" | "NSM" | "B";

    /**
     * The Unicode character's combining class.
     * Example: "0" for a base character.
     */
    combining_class: number;

    /**
     * The Unicode character's decimal digit value, if applicable.
     * Example: "2" for the character '2'.
     */
    decimal_digit_value: number | null;

    /**
     * The Unicode character's mirrored property.
     * Example: "Y" for mirrored.
     */
    mirrored: "Y" | "N";

    /**
     * The Unicode character's uppercase mapping.
     * Example: "A" for lowercase 'a'.
     */
    uppercase_mapping: string | null;

    /**
     * The Unicode character's lowercase mapping.
     * Example: "a" for uppercase 'A'.
     */
    lowercase_mapping: string | null;

    /**
     * The Unicode character's titlecase mapping.
     * Example: "A" for titlecase 'a'.
     */
    titlecase_mapping: string | null;
}

export const DERIVED_CORE_PROPERTIES_FIELDS = [
    "general_category",
    "script",
    "numeric_value",
    "bidi_category",
    "combining_class",
    "decimal_digit_value",
    "mirrored",
    "uppercase_mapping",
    "lowercase_mapping",
    "titlecase_mapping"
];
//#endregion

//#region data-files/v6.1.0/DerivedNormalizationProps.txt
/**
 * Interface representing the properties for DerivedNormalization.
 */
export interface DerivedNormalization {
    /**
     * The Unicode character that is being normalized.
     * Format: "U+XXXX" where XXXX is a hexadecimal value.
     */
    unicode_character: string;

    /**
     * The normalization form applied to the character.
     * Union types: "NFC", "NFD", "NFKC", "NFKD"
     */
    normalization_form: "NFC" | "NFD" | "NFKC" | "NFKD";

    /**
     * The result of the normalization process.
     * Format: A string representing the normalized character.
     */
    normalized_result: string;

    /**
     * A flag indicating whether the normalization was successful.
     * Format: boolean
     */
    success: boolean;

    /**
     * An optional message providing additional information about the normalization process.
     * Format: string
     */
    message?: string;
}

export const DERIVED_NORMALIZATION_FIELDS = [
    "unicode_character",
    "normalization_form",
    "normalized_result",
    "success",
    "message"
];
//#endregion

//#region data-files/v6.1.0/EastAsianWidth.txt
/**
 * EastAsianWidth
 *
 * This interface represents the East Asian Width properties for Unicode characters.
 * Each character is associated with a Unicode value and its corresponding East Asian Width property.
 *
 * The East Asian Width property can take one of the following values:
 * - "N": Not East Asian
 * - "A": Ambiguous
 * - "H": Half-width
 * - "W": Full-width
 * - "F": Full-width (for compatibility)
 * - "Na": Not applicable
 *
 * All code points, assigned or unassigned, that are not listed explicitly are given the value "N".
 *
 * Unassigned code points that default to "W" include ranges in specific blocks such as:
 * - CJK Unified Ideographs Extension A: U+3400..U+4DBF
 * - CJK Unified Ideographs: U+4E00..U+9FFF
 * - CJK Compatibility Ideographs: U+F900..U+FAFF
 * - CJK Unified Ideographs Extension B: U+20000..U+2A6DF
 * - CJK Unified Ideographs Extension C: U+2A700..U+2B73F
 * - CJK Unified Ideographs Extension D: U+2B740..U+2B81F
 * - CJK Compatibility Ideographs Supplement: U+2F800..U+2FA1F
 * - Any other reserved code points on Planes 2 and 3: U+20000..U+2FFFD, U+30000..U+3FFFD
 */
export interface EastAsianWidth {
  /** Unicode value */
  unicode_value: string;
  /** East Asian Width property */
  east_asian_width_property: "N" | "A" | "H" | "W" | "F" | "Na";
}

export const EAST_ASIAN_WIDTH_FIELDS = [
  "unicode_value",
  "east_asian_width_property"
];
//#endregion

//#region data-files/v6.1.0/EmojiSources.txt
/**
 * Interface representing the mappings between Unicode code points and Shift-JIS codes for cell phone carrier symbols.
 */
export interface EmojiSources {
    /**
     * Unicode code point or sequence.
     * Example: "U+1F600"
     */
    unicode_code_point_or_sequence: string;
    /**
     * DoCoMo Shift-JIS code, if available.
     * Example: "0xE63A"
     */
    docomo_shift_jis_code: string | null;
    /**
     * KDDI Shift-JIS code, if available.
     * Example: "0xE63B"
     */
    kddi_shift_jis_code: string | null;
    /**
     * SoftBank Shift-JIS code, if available.
     * Example: "0xE63C"
     */
    softbank_shift_jis_code: string | null;
}

export const EMOJI_SOURCES_FIELDS = [
    "unicode_code_point_or_sequence",
    "docomo_shift_jis_code",
    "kddi_shift_jis_code",
    "softbank_shift_jis_code"
];
//#endregion

//#region data-files/v6.1.0/HangulSyllableType.txt
/**
 * Interface representing the Hangul Syllable Type data.
 */
export interface HangulSyllableType {
    /**
     * The Hangul syllable type code.
     * Format: "A", "B", "C"
     */
    code: "A" | "B" | "C";

    /**
     * The description of the syllable type.
     * Example: "Consonant", "Vowel"
     */
    description: string;

    /**
     * The Unicode range for the syllable type.
     * Format: "U+AC00-U+D7A3"
     */
    unicode_range: string;
}

export const HANGUL_SYLLABLE_TYPE_FIELDS = [
    "code",
    "description",
    "unicode_range"
];
//#endregion

//#region data-files/v6.1.0/IndicMatraCategory.txt
/**
 * This interface defines the provisional property for Indic Matra Categories.
 * It is aimed at the specification of syllabic structure for Indic scripts.
 *
 * The property is designed primarily to supplement the Indic_Syllabic_Category property.
 *
 * Note: This property is not intended as a prescriptive property regarding display or font design.
 */
export interface IndicMatraCategory {
    /**
     * Code Point or Code Point Range
     * Format: A single code point or a range of code points (e.g., U+0900, U+0900-U+090F)
     */
    code_point: string;

    /**
     * Indic Matra Category
     * This field indicates the category of the matra, which can be one of several types.
     * Example values: "dependent vowel", "virama"
     */
    indic_matra_category: "dependent vowel" | "virama";
}

export const INDIC_MATRA_CATEGORY_FIELDS = [
    "code_point",
    "indic_matra_category"
];
//#endregion

//#region data-files/v6.1.0/IndicSyllabicCategory.txt
/**
 * This interface defines the Indic Syllabic Category property, which is used to specify the syllabic structure and segmentation rules for Indic scripts.
 */
export interface IndicSyllabicCategory {
    /**
     * The code point or code point range for the character(s).
     * Format: U+XXXX or U+XXXX..U+YYYY
     * Example: U+0905 for the character 'à¤…'
     */
    code_point: string;

    /**
     * The Indic syllabic category of the character(s).
     * Possible values include:
     * - "Vowel"
     * - "Consonant"
     * - "Vowel_Consonant"
     * - "Consonant_Cluster"
     * - "Other"
     */
    indic_syllabic_category: "Vowel" | "Consonant" | "Vowel_Consonant" | "Consonant_Cluster" | "Other";
}

export const INDIC_SYLLABIC_CATEGORY_FIELDS = [
    "code_point",
    "indic_syllabic_category"
];
//#endregion

//#region data-files/v6.1.0/Jamo.txt
/**
 * This interface defines the Jamo_Short_Name property.
 *
 * Each entry represents a conjoining jamo character that participates in the algorithmic determination of Hangul syllable character names.
 *
 * @property {"string"} code_point - The code point of a conjoining jamo character in 4-digit hexadecimal form (e.g., "1100").
 * @property {"string"} jamo_short_name - The Jamo_Short_Name as a one-, two-, or three-character ASCII string (e.g., "G", "GG", "N").
 */
export interface Jamo {
  "code_point": string;
  "jamo_short_name": string;
}

export const JAMO_FIELDS = [
  "code_point",
  "jamo_short_name"
];
//#endregion

//#region data-files/v6.1.0/LineBreak.txt
/**
 * This interface represents the line break properties for Unicode characters.
 */
export interface LineBreak {
    /**
     * The Unicode value of the character.
     * Example: U+0041 for 'A'
     */
    unicode_value: string;
    /**
     * The line break property of the character.
     * Can be one of the following values:
     * - Normative: "BK", "CR", "LF", "CM", "SG", "GL", "CB", "SP", "ZW", "NL", "WJ", "JL", "JV", "JT", "H2", "H3"
     * - Informative: "XX", "OP", "CL", "CP", "QU", "NS", "EX", "SY", "IS", "PR", "PO", "NU", "AL", "ID", "IN", "HY", "BB", "BA", "SA", "AI", "B2", "HL", "CJ"
     * Example: "BK"
     */
    line_break_property: "BK" | "CR" | "LF" | "CM" | "SG" | "GL" | "CB" | "SP" | "ZW" | "NL" | "WJ" | "JL" | "JV" | "JT" | "H2" | "H3" | "XX" | "OP" | "CL" | "CP" | "QU" | "NS" | "EX" | "SY" | "IS" | "PR" | "PO" | "NU" | "AL" | "ID" | "IN" | "HY" | "BB" | "BA" | "SA" | "AI" | "B2" | "HL" | "CJ";
}

export const LINE_BREAK_FIELDS = [
    "unicode_value",
    "line_break_property"
];
//#endregion

//#region data-files/v6.1.0/NameAliases.txt
/**
 * This interface defines the formal name aliases for Unicode characters.
 */
export interface NameAliases {
  /**
   * The code point of the Unicode character, represented in hexadecimal format.
   * Example: "U+0041" for the character 'A'.
   */
  code_point: string;

  /**
   * The alias for the Unicode character, which can be a correction, control, alternate, figment, or abbreviation.
   * Example: "LATIN CAPITAL LETTER A".
   */
  alias: string;

  /**
   * The type of the alias, which can be one of the following: "correction", "control", "alternate", "figment", "abbreviation".
   * Example: "control" for control characters.
   */
  type: "correction" | "control" | "alternate" | "figment" | "abbreviation";
}

export const NAME_ALIASES_FIELDS = [
  "code_point",
  "alias",
  "type"
];
//#endregion

//#region data-files/v6.1.0/NamedSequences.txt
/**
 * Represents a named sequence of Unicode code points.
 */
export interface NamedSequences {
    /**
     * The name of the sequence.
     */
    name: string;

    /**
     * The code point sequence represented as a string of space-separated values.
     * Example: "1000 1001 1002"
     */
    code_point_sequence: string;
}

export const NAMED_SEQUENCES_FIELDS = [
    "name",
    "code_point_sequence"
];
//#endregion

//#region data-files/v6.1.0/NamedSequencesProv.txt
/**
 * Interface representing the Provisional Named Sequences from the Unicode Character Database.
 */
export interface NamedSequencesProv {
    /**
     * The name of the sequence.
     */
    name: string;

    /**
     * The code point sequence represented as a string of space-separated values.
     * Example: "1000 1001 1002"
     */
    code_point_sequence: string;
}

export const NAMED_SEQUENCES_PROV_FIELDS = [
    "name",
    "code_point_sequence"
];
//#endregion

//#region data-files/v6.1.0/NormalizationCorrections.txt
/**
 * This interface represents the normalization corrections as specified in the Unicode Character Database.
 */
export interface NormalizationCorrections {
  /**
   * Unicode code point, represented as a hexadecimal string (e.g., "U+0041").
   */
  unicode_code_point: string;
  /**
   * Original (erroneous) decomposition of the character.
   */
  original_decomposition: string;
  /**
   * Corrected decomposition of the character.
   */
  corrected_decomposition: string;
  /**
   * Version of Unicode for which the correction was entered, in n.n.n format (e.g., "6.1.0").
   */
  unicode_version: string;
  /**
   * Indicates the Unicode Corrigendum which documents the correction.
   */
  comment: string;
}

export const NORMALIZATION_CORRECTIONS_FIELDS = [
  "unicode_code_point",
  "original_decomposition",
  "corrected_decomposition",
  "unicode_version",
  "comment"
];
//#endregion

//#region data-files/v6.1.0/NormalizationTest.txt
/**
 * Interface representing the normalization test suite data.
 */
export interface NormalizationTest {
    /**
     * The source code points to be normalized.
     * Example: "U+0041; U+0061"
     */
    source: string;
    /**
     * The normalized form in NFC.
     * Example: "U+0041"
     */
    nfc: string;
    /**
     * The normalized form in NFD.
     * Example: "U+0041"
     */
    nfd: string;
    /**
     * The normalized form in NFKC.
     * Example: "U+0041"
     */
    nfkc: string;
    /**
     * The normalized form in NFKD.
     * Example: "U+0041"
     */
    nfkd: string;
}

export const NORMALIZATION_TEST_FIELDS = [
    "source",
    "nfc",
    "nfd",
    "nfkc",
    "nfkd"
];
//#endregion

//#region data-files/v6.1.0/PropList.txt
/**
 * Interface representing the Unicode Character Database properties.
 */
export interface PropList {
    /**
     * The date when the database was generated.
     * Format: "YYYY-MM-DD HH:MM:SS GMT"
     * Example: "2011-11-30 01:49:54 GMT"
     */
    date: string;

    /**
     * The copyright information for the database.
     * Example: "Copyright (c) 1991-2011 Unicode, Inc."
     */
    copyright: string;

    /**
     * The terms of use for the database.
     * Example: "For terms of use, see http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;

    /**
     * The documentation link for the database.
     * Example: "For documentation, see http://www.unicode.org/reports/tr44/"
     */
    documentation: string;
}

export const PROP_LIST_FIELDS = [
    "date",
    "copyright",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v6.1.0/PropertyAliases.txt
/**
 * This interface defines the property aliases used in the Unicode Character Database (UCD).
 * The properties include abbreviated names, long names, and additional aliases for Unicode data.
 *
 * Each property is defined with the following fields:
 * - `abbreviated_name`: A short name for the property (e.g., "AL").
 * - `long_name`: A detailed name for the property (e.g., "Arabic Letter").
 * - `additional_aliases`: Other names that can be used for the property (optional).
 *
 * Note: Property value names are not unique across properties, and some property names may be the same as property value names.
 * For example, "AL" can refer to different meanings in different contexts.
 */
export interface PropertyAliases {
  abbreviated_name: string;
  long_name: string;
  additional_aliases?: string[];
}

export const PROPERTY_ALIASES_FIELDS = [
  "abbreviated_name",
  "long_name",
  "additional_aliases"
];
//#endregion

//#region data-files/v6.1.0/PropertyValueAliases.txt
/**
 * This interface represents the property value aliases used in the Unicode Character Database (UCD).
 *
 * Each property value name consists of the following fields:
 * - `property`: The property for which the property value name is used.
 * - `abbreviated_name`: An abbreviated name for the property value.
 * - `long_name`: A long descriptive name for the property value.
 *
 * In the case of the `ccc` property, there are four fields:
 * - `property`: The property for which the property value name is used.
 * - `numeric`: A numeric representation of the property value.
 * - `abbreviated_name`: An abbreviated name for the property value.
 * - `long_name`: A long descriptive name for the property value.
 *
 * Note that property value names are not unique across properties, and some property names may be the same as property value names.
 * For example, `AL` can mean different things in different contexts.
 *
 * Loose matching is applied to all property names and values, with exceptions for string property values.
 * Numeric equivalencies are also applied, such as "01.00" being equivalent to "1".
 */
export interface PropertyValueAliases {
    property: string;
    abbreviated_name: string;
    long_name: string;
    numeric?: number;
}

export const PROPERTY_VALUE_ALIASES_FIELDS = [
    "property",
    "abbreviated_name",
    "long_name",
    "numeric"
];
//#endregion

//#region data-files/v6.1.0/ScriptExtensions.txt
/**
 * The ScriptExtensions interface represents the Unicode Script Extensions property,
 * which indicates which characters are commonly used with a limited number of scripts,
 * but with more than one. The property is provisional and values may change over time.
 */
export interface ScriptExtensions {
    /**
     * The code point of the character.
     * Example: U+0041 for 'A'
     */
    code_point: string;
    /**
     * The script property value(s) associated with the code point.
     * Example: "Latin", "Cyrillic"
     */
    script_property_values: string[];
}

export const SCRIPT_EXTENSIONS_FIELDS = [
    "code_point",
    "script_property_values"
];
//#endregion

//#region data-files/v6.1.0/Scripts.txt
/**
 * Interface representing the Unicode Character Database.
 */
export interface Scripts {
    /**
     * The date when the data was last updated.
     * Format: "YYYY-MM-DD HH:MM:SS GMT"
     * Example: "2011-11-27 05:10:50 GMT"
     */
    date: string;

    /**
     * The version of the scripts data.
     * Format: "X.X.X"
     * Example: "6.1.0"
     */
    version: string;

    /**
     * The copyright information for the Unicode Character Database.
     * Example: "Copyright (c) 1991-2011 Unicode, Inc."
     */
    copyright: string;

    /**
     * The terms of use for the Unicode Character Database.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;

    /**
     * The documentation link for the Unicode Character Database.
     * Example: "http://www.unicode.org/reports/tr44/"
     */
    documentation: string;
}

export const SCRIPTS_FIELDS = [
    "date",
    "version",
    "copyright",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v6.1.0/SpecialCasing.txt
/**
 * This interface represents the special casing properties of Unicode characters.
 */
export interface SpecialCasing {
    /**
     * The code point of the character in hexadecimal format.
     * Example: "0041" for 'A'
     */
    code: string;

    /**
     * The lowercase mapping of the character in hexadecimal format.
     * Example: "0061" for 'a'
     */
    lower: string;

    /**
     * The titlecase mapping of the character in hexadecimal format.
     * Example: "0041" for 'A'
     */
    title: string;

    /**
     * The uppercase mapping of the character in hexadecimal format.
     * Example: "0041" for 'A'
     */
    upper: string;

    /**
     * A list of conditions that override the normal behavior of casing.
     * Example: "en" for English, "Not_fr" for not French
     */
    condition_list?: string;

    /**
     * A comment providing additional information about the entry.
     */
    comment?: string;
}

export const SPECIAL_CASING_FIELDS = [
    "code",
    "lower",
    "title",
    "upper",
    "condition_list",
    "comment"
];
//#endregion

//#region data-files/v6.1.0/StandardizedVariants.txt
/**
 * Standardized variation sequences defined in the Unicode Standard.
 */
export interface StandardizedVariants {
  /**
   * The variation sequence.
   * Example: "[0;31m"
   */
  variation_sequence: string;

  /**
   * The description of the desired appearance.
   * Example: "Red text"
   */
  description: string;

  /**
   * Indicates where the appearance is only different in particular shaping environments.
   * Example: "Terminal, Web"
   */
  shaping_environments: string;
}

export const STANDARDIZED_VARIANTS_FIELDS = [
  "variation_sequence",
  "description",
  "shaping_environments"
];
//#endregion

//#region data-files/v6.1.0/extracted/DerivedBidiClass.txt
/**
 * Interface representing the DerivedBidiClass.
 */
export interface DerivedBidiClass {
    /**
     * The Unicode character code point.
     * Example: 65 for 'A'
     */
    code_point: number;

    /**
     * The directionality of the character.
     * Can be "L" for Left-to-Right, "R" for Right-to-Left, or "AL" for Arabic Letter.
     */
    directionality: "L" | "R" | "AL";

    /**
     * The category of the character.
     * Example: "Lu" for Uppercase Letter
     */
    category: string;

    /**
     * The bidirectional class of the character.
     * Example: "B" for Boundary
     */
    bidi_class: string;

    /**
     * The mirrored property of the character.
     * Can be "Y" for Yes or "N" for No.
     */
    mirrored: "Y" | "N";

    /**
     * The combining class of the character.
     * Example: 0 for Not a Combining Character
     */
    combining_class: number;

    /**
     * The upper case mapping of the character.
     * Example: 'A' for 'a'
     */
    upper_case: string;

    /**
     * The lower case mapping of the character.
     * Example: 'a' for 'A'
     */
    lower_case: string;
}

export const DERIVED_BIDI_CLASS_FIELDS = [
    "code_point",
    "directionality",
    "category",
    "bidi_class",
    "mirrored",
    "combining_class",
    "upper_case",
    "lower_case"
];
//#endregion

//#region data-files/v6.1.0/extracted/DerivedBinaryProperties.txt
/**
 * Interface representing the derived binary properties from the Unicode Character Database.
 */
export interface DerivedBinaryProperties {
    /**
     * The property name, represented as a string.
     * Example: "Bidi_Control"
     */
    property_name: string;
    
    /**
     * The value of the property, which can be a union of specific string values.
     * Example: "Yes" | "No"
     */
    property_value: "Yes" | "No";
    
    /**
     * The date when the property was last updated, formatted as YYYY-MM-DD.
     * Example: "2011-07-25"
     */
    last_updated: string;
}

export const DERIVED_BINARY_PROPERTIES_FIELDS = [
    "property_name",
    "property_value",
    "last_updated"
];
//#endregion

//#region data-files/v6.1.0/extracted/DerivedCombiningClass.txt
/**
 * Interface representing the Unicode Character Database derived combining class.
 */
export interface DerivedCombiningClass {
    /**
     * The combining class value, which is a non-negative integer.
     * Example: 0, 1, 2, ...
     */
    combining_class: number;

    /**
     * The canonical combining class value, which is a non-negative integer.
     * Example: 0, 1, 2, ...
     */
    canonical_combining_class: number;

    /**
     * The name of the derived combining class.
     * Example: "Not Reordered", "Reordered"
     */
    name: string;

    /**
     * The description of the derived combining class.
     * Example: "This class is used for characters that do not affect the base character."
     */
    description: string;
}

export const DERIVED_COMBINING_CLASS_FIELDS = [
    "combining_class",
    "canonical_combining_class",
    "name",
    "description"
];
//#endregion

//#region data-files/v6.1.0/extracted/DerivedDecompositionType.txt
/**
 * Interface representing the Unicode Character Database derived decomposition type.
 */
export interface DerivedDecompositionType {
    /**
     * The character that is decomposed.
     * Example: 'A'
     */
    character: string;

    /**
     * The decomposition mapping for the character.
     * Example: 'A' -> 'A' + 'Ìµ'
     */
    decomposition: string;

    /**
     * The type of decomposition.
     * Can be one of the following: "canonical", "compatibility"
     */
    type: "canonical" | "compatibility";

    /**
     * The Unicode code point of the character.
     * Example: 65 for 'A'
     */
    code_point: number;
}

export const DERIVED_DECOMPOSITION_TYPE_FIELDS = [
    "character",
    "decomposition",
    "type",
    "code_point"
];
//#endregion

//#region data-files/v6.1.0/extracted/DerivedEastAsianWidth.txt
/**
 * Interface representing the DerivedEastAsianWidth data.
 */
export interface DerivedEastAsianWidth {
    /**
     * The character code point in hexadecimal format.
     * Example: "U+0041" for the character 'A'.
     */
    code_point: string;

    /**
     * The East Asian width category of the character.
     * Possible values: "Narrow", "Wide", "Fullwidth", "Halfwidth", "Ambiguous".
     */
    east_asian_width: "Narrow" | "Wide" | "Fullwidth" | "Halfwidth" | "Ambiguous";

    /**
     * The Unicode version in which the character was introduced.
     * Example: "6.1.0".
     */
    unicode_version: string;

    /**
     * The date when the character was added to the Unicode standard.
     * Format: YYYY-MM-DD.
     * Example: "2011-11-27".
     */
    date_added: string;
}

export const DERIVED_EAST_ASIAN_WIDTH_FIELDS = [
    "code_point",
    "east_asian_width",
    "unicode_version",
    "date_added"
];
//#endregion

//#region data-files/v6.1.0/extracted/DerivedGeneralCategory.txt
/**
 * Interface representing the Unicode Character Database derived general category.
 */
export interface DerivedGeneralCategory {
    /**
     * The general category of the character, represented as a string.
     * Example: "Lu" for uppercase letters.
     */
    general_category: "Lu" | "Ll" | "Lt" | "Lm" | "Lo" | "Mn" | "Mc" | "Me" | "Nd" | "Nl" | "No" | "Pc" | "Pd" | "Ps" | "Pe" | "Pi" | "Pf" | "Po" | "Sm" | "Sc" | "Sk" | "So" | "Zs" | "Zl" | "Zp";

    /**
     * The numeric value associated with the character, if applicable.
     * Example: 1 for a character that represents a single unit.
     */
    numeric_value?: number;

    /**
     * The name of the character in Unicode.
     * Example: "LATIN CAPITAL LETTER A".
     */
    character_name: string;

    /**
     * The code point of the character, represented as a hexadecimal string.
     * Example: "0041" for the character 'A'.
     */
    code_point: string;
}

export const DERIVED_GENERAL_CATEGORY_FIELDS = [
    "general_category",
    "numeric_value",
    "character_name",
    "code_point"
];
//#endregion

//#region data-files/v6.1.0/extracted/DerivedJoiningGroup.txt
/**
 * Interface representing the Unicode Character Database derived joining group.
 */
export interface DerivedJoiningGroup {
    /**
     * The name of the derived joining group.
     * Example: "Left"
     */
    derived_joining_group_name: string;
    
    /**
     * The code point of the character.
     * Example: "U+0041"
     */
    code_point: string;
    
    /**
     * The joining type of the character.
     * Example: "D"
     */
    joining_type: "D" | "L" | "R" | "A";
}

export const DERIVED_JOINING_GROUP_FIELDS = [
    "derived_joining_group_name",
    "code_point",
    "joining_type"
];
//#endregion

//#region data-files/v6.1.0/extracted/DerivedJoiningType.txt
/**
 * Interface representing the Unicode Character Database derived joining types.
 */
export interface DerivedJoiningType {
    /**
     * The character's derived joining type.
     * Example: "D" for Dual Joining.
     */
    derived_joining_type: "D" | "L" | "R" | "U" | "C" | "T" | "A";

    /**
     * The character's code point in hexadecimal format.
     * Example: "U+0061" for the character 'a'.
     */
    code_point: string;

    /**
     * The character's name.
     * Example: "LATIN SMALL LETTER A".
     */
    character_name: string;

    /**
     * The character's numeric value, if applicable.
     * Example: 1 for 'A' in some contexts.
     */
    numeric_value?: number;
}

export const DERIVED_JOINING_TYPE_FIELDS = [
    "derived_joining_type",
    "code_point",
    "character_name",
    "numeric_value"
];
//#endregion

//#region data-files/v6.1.0/extracted/DerivedLineBreak.txt
/**
 * Interface representing the Unicode Character Database derived line break properties.
 */
export interface DerivedLineBreak {
    /**
     * The date when the data was last updated.
     * Format: YYYY-MM-DD, HH:MM:SS GMT
     * Example: "2011-11-27, 05:10:24 GMT"
     */
    date: string;

    /**
     * The source of the data, including copyright information.
     * Example: "Unicode Character Database"
     */
    source: string;

    /**
     * The copyright holder of the data.
     * Example: "Copyright (c) 1991-2011 Unicode, Inc."
     */
    copyright: string;

    /**
     * The terms of use for the data.
     * Example: "For terms of use, see http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;

    /**
     * The documentation reference for the data.
     * Example: "For documentation, see http://www.unicode.org/reports/tr44/"
     */
    documentation: string;
}

export const DERIVED_LINE_BREAK_FIELDS = [
    "date",
    "source",
    "copyright",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v6.1.0/extracted/DerivedNumericType.txt
/**
 * Interface representing the DerivedNumericType.
 */
export interface DerivedNumericType {
    /**
     * The date of the entry in ISO 8601 format.
     * Example: "2011-08-23T00:47:14Z"
     */
    date: string;
    /**
     * The source of the Unicode Character Database.
     * Example: "Unicode, Inc."
     */
    source: string;
    /**
     * The terms of use URL for the Unicode Character Database.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;
    /**
     * The documentation URL for the Unicode Character Database.
     * Example: "http://www.unicode.org/reports/tr44/"
     */
    documentation: string;
}

export const DERIVED_NUMERIC_TYPE_FIELDS = [
    "date",
    "source",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v6.1.0/extracted/DerivedNumericValues.txt
/**
 * Interface representing the derived numeric values from the Unicode Character Database.
 */
export interface DerivedNumericValues {
    /**
     * The numeric value associated with a character.
     * Example: "1.0"
     */
    numeric_value: string;

    /**
     * The type of the numeric value.
     * Example: "integer" or "decimal"
     */
    numeric_type: "integer" | "decimal";

    /**
     * The character associated with the numeric value.
     * Example: "A"
     */
    character: string;

    /**
     * The source of the numeric value.
     * Example: "Derived" or "Explicit"
     */
    source: "Derived" | "Explicit";
}

export const DERIVED_NUMERIC_VALUES_FIELDS = [
    "numeric_value",
    "numeric_type",
    "character",
    "source"
];
//#endregion

//#region data-files/v6.1.0/auxiliary/GraphemeBreakProperty.txt
/**
 * Interface representing the GraphemeBreakProperty data.
 */
export interface GraphemeBreakProperty {
    /**
     * The character that represents the grapheme break property.
     * Example: "CR" for Carriage Return.
     */
    character: string;

    /**
     * The Unicode code point of the character.
     * Example: 0x0A for Line Feed.
     */
    code_point: number;

    /**
     * The description of the grapheme break property.
     * Example: "Control" for control characters.
     */
    description: string;

    /**
     * The category of the grapheme break property.
     * Example: "L" for Letter.
     */
    category: "L" | "V" | "T" | "LV" | "LVT";
}

export const GRAPHEME_BREAK_PROPERTY_FIELDS = [
    "character",
    "code_point",
    "description",
    "category"
];
//#endregion

//#region data-files/v6.1.0/auxiliary/GraphemeBreakTest.txt
/**
 * GraphemeBreakTest
 *
 * This interface represents the default grapheme break test as defined in the Unicode Character Database.
 */
export interface GraphemeBreakTest {
    /**
     * A string containing hex Unicode code points.
     * Example: "0041 0042 0043"
     */
    unicode_code_points: string;

    /**
     * An optional comment associated with the string.
     * Example: "# This is a comment"
     */
    comment?: string;
}

export const GRAPHEME_BREAK_TEST_FIELDS = [
    "unicode_code_points",
    "comment"
];
//#endregion

//#region data-files/v6.1.0/auxiliary/LineBreakTest.txt
/**
 * Default Line Break Test
 */
export interface LineBreakTest {
    /**
     * The string contains hex Unicode code points.
     * Format: <string> (# <comment>)?
     * Example: "0041" (represents 'A')
     */
    string: string;
}

export const LINE_BREAK_TEST_FIELDS = [
    "string"
];
//#endregion

//#region data-files/v6.1.0/auxiliary/SentenceBreakProperty.txt
/**
 * Interface representing the properties defined in the SentenceBreakProperty Unicode Character Database.
 */
export interface SentenceBreakProperty {
    /**
     * The Unicode character that represents the property.
     * Example: 'A'
     */
    character: string;

    /**
     * The property value associated with the character.
     * Example: 'AL'
     */
    property_value: string;

    /**
     * The description of the property value.
     * Example: 'Alphabetic'
     */
    description: string;

    /**
     * The numeric code point of the character.
     * Example: 65 for 'A'
     */
    code_point: number;

    /**
     * The category of the character.
     * Example: 'Letter'
     */
    category: string;
}

export const SENTENCE_BREAK_PROPERTY_FIELDS = [
    "character",
    "property_value",
    "description",
    "code_point",
    "category"
];
//#endregion

//#region data-files/v6.1.0/auxiliary/SentenceBreakTest.txt
/**
 * Interface representing the Default Sentence Break Test.
 */
export interface SentenceBreakTest {
    /**
     * The date and time of the test in GMT format.
     * Example: "2011-08-23, 19:45:22 GMT"
     */
    date: string;

    /**
     * The Unicode character database copyright information.
     * Example: "Copyright (c) 1991-2011 Unicode, Inc."
     */
    copyright: string;

    /**
     * The terms of use for the Unicode character database.
     * Example: "For terms of use, see http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;

    /**
     * The documentation link for the Unicode character database.
     * Example: "For documentation, see http://www.unicode.org/reports/tr44/"
     */
    documentation: string;

    /**
     * The format of the sentence break test.
     * Example: "<string> (# <comment>)?"
     */
    format: string;

    /**
     * Description of the string format containing hex Unicode code points.
     */
    string_description: string;
}

export const SENTENCE_BREAK_TEST_FIELDS = [
    "date",
    "copyright",
    "terms_of_use",
    "documentation",
    "format",
    "string_description"
];
//#endregion

//#region data-files/v6.1.0/auxiliary/WordBreakProperty.txt
/**
 * Interface representing the WordBreakProperty.
 */
export interface WordBreakProperty {
    /**
     * The word break property value.
     * 
     * This property can take one of the following values:
     * - "normal": Default word breaking behavior.
     * - "break-all": Break words at any character.
     * - "keep-all": Do not break words.
     * - "break-word": Break words only at allowed break points.
     */
    word_break: "normal" | "break-all" | "keep-all" | "break-word";
}

export const WORD_BREAK_PROPERTY_FIELDS = [
    "word_break"
];
//#endregion

//#region data-files/v6.1.0/auxiliary/WordBreakTest.txt
/**
 * Default Word Break Test
 *
 * This interface represents the structure of the default word break test data.
 */
export interface WordBreakTest {
    /**
     * A string containing hex Unicode code points.
     * Example: "0061 0062 0063"
     */
    code_points: string;
    /**
     * An optional comment associated with the code points.
     * Example: "# This is a comment"
     */
    comment?: string;
}

export const WORD_BREAK_TEST_FIELDS = [
    "code_points",
    "comment"
];
//#endregion

