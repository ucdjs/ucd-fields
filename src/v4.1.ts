// This file is generated by ucd codegen. Do not edit this file directly.
// Unicode Version: 4.1


// #region ArabicShaping
export interface ArabicShaping {
  code_point: string; // The code point of an Arabic or Syriac character, in 4-digit hexadecimal form
  name: string; // A short schematic name for the character, abbreviated from the normative Unicode character name
  joining_type: "R" | "L" | "D" | "C" | "U" | "T"; // Defines the joining type (R = Right_Joining, L = Left_Joining, D = Dual_Joining, C = Join_Causing, U = Non_Joining, T = Transparent)
  joining_group: string; // Defines the joining group, based schematically on character names
}

export const ARABIC_SHAPING_FIELDS = [
  "code_point",
  "name",
  "joining_type",
  "joining_group"
];

// #endregion

// #region BidiMirroring
export interface BidiMirroring {
  code_point: string; // The code point of a character, in hexadecimal form
  mirrored_code_point: string; // The code point of the character that is the mirror image of the original character's glyph
}

export const BIDI_MIRRORING_FIELDS = [
  "code_point",
  "mirrored_code_point"
];

// #endregion

// #region Blocks
export interface Blocks {
  start_code: string; // The starting code point of the block, in hexadecimal form
  end_code: string; // The ending code point of the block, in hexadecimal form
  block_name: string; // The name of the Unicode block
}

export const BLOCKS_FIELDS = [
  "start_code",
  "end_code",
  "block_name"
];

// #endregion

// #region CaseFolding
export interface CaseFolding {
  code: string; // The Unicode code point of the character, in hexadecimal form
  status: "C" | "F" | "S" | "T"; // The status of the case folding mapping
  mapping: string; // The case folding mapping for the character
  name: string; // A short schematic name for the character
}

export const CASE_FOLDING_FIELDS = [
  "code",
  "status",
  "mapping",
  "name"
];

// #endregion

// #region CompositionExclusions
export interface CompositionExclusions {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const COMPOSITION_EXCLUSIONS_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedAge
export interface DerivedAge {
  type_name: string; // The name of the derived property type
}

export const DERIVED_AGE_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedCoreProperties
export interface DerivedCoreProperties {
  type_name: string; // The name of the type as specified in the Unicode Character Database
}

export const DERIVED_CORE_PROPERTIES_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedNormalizationProps
export interface DerivedNormalizationProps {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
  joining_type: "R" | "L" | "D" | "C" | "U" | "T"; // Defines the joining type (R = Right_Joining, L = Left_Joining, D = Dual_Joining, C = Join_Causing, U = Non_Joining, T = Transparent)
  joining_group: string; // Defines the joining group, based schematically on character names
}

export const DERIVED_NORMALIZATION_PROPS_FIELDS = [
  "code_point",
  "name",
  "joining_type",
  "joining_group"
];

// #endregion

// #region EastAsianWidth
export interface EastAsianWidth {
  unicode_value: string; // The Unicode value of the character, typically represented in hexadecimal form.
  east_asian_width_property: "N" | "A" | "H" | "W" | "F" | "Na"; // The East Asian Width property of the character, indicating its width category.
}

export const EAST_ASIAN_WIDTH_FIELDS = [
  "unicode_value",
  "east_asian_width_property"
];

// #endregion

// #region HangulSyllableType
export interface HangulSyllableType {
  type_name: string; // The name of the type as defined in the Unicode Character Database.
}

export const HANGUL_SYLLABLE_TYPE_FIELDS = [
  "type_name"
];

// #endregion

// #region Jamo
export interface Jamo {
  code_point: string; // The code point of a combining jamo character, in 4-digit hexadecimal form
  jamo_short_name: string; // The Jamo Short Name as a one-, two-, or three-character ASCII string
}

export const JAMO_FIELDS = [
  "code_point",
  "jamo_short_name"
];

// #endregion

// #region LineBreak
export interface LineBreak {
  unicode_value: string; // The Unicode value of the character, typically represented in hexadecimal form.
  line_break_property: "BK" | "CR" | "LF" | "CM" | "SG" | "GL" | "CB" | "SP" | "ZW" | "NL" | "WJ" | "JL" | "JV" | "JT" | "H2" | "H3" | "XX" | "OP" | "CL" | "QU" | "NS" | "EX" | "SY" | "IS" | "PR" | "PO" | "NU" | "AL" | "ID" | "IN" | "HY" | "BB" | "BA" | "SA" | "AI" | "B2"; // The line break property of the character, which can be one of several normative or informative values.
}

export const LINE_BREAK_FIELDS = [
  "unicode_value",
  "line_break_property"
];

// #endregion

// #region NamedSequences
export interface NamedSequences {
  name_of_sequence: string; // The name of the sequence as defined in the Unicode Character Database.
  code_point_sequence: string; // The code point sequence for the Unicode Standard Identifier (USI).
}

export const NAMED_SEQUENCES_FIELDS = [
  "name_of_sequence",
  "code_point_sequence"
];

// #endregion

// #region NormalizationCorrections
export interface NormalizationCorrections {
  unicode_code_point: string; // The Unicode code point of the character, in hexadecimal form
  original_decomposition: string; // The original (erroneous) decomposition of the character
  corrected_decomposition: string; // The corrected decomposition of the character
  unicode_version: string; // The version of Unicode for which the correction was entered, in n.n.n format
  comment: string; // Indicates the Unicode Corrigendum which documents the correction
}

export const NORMALIZATION_CORRECTIONS_FIELDS = [
  "unicode_code_point",
  "original_decomposition",
  "corrected_decomposition",
  "unicode_version",
  "comment"
];

// #endregion

// #region PropList
export interface PropList {
  type_name: string; // The name of the type as specified in the Unicode Character Database
}

export const PROP_LIST_FIELDS = [
  "type_name"
];

// #endregion

// #region PropertyAliases
export interface PropertyAliases {
  abbreviated_name: string; // An abbreviated name for the property.
  long_name: string; // A long name for the property.
  additional_aliases: string[]; // Additional aliases for the property.
}

export const PROPERTY_ALIASES_FIELDS = [
  "abbreviated_name",
  "long_name",
  "additional_aliases"
];

// #endregion

// #region PropertyValueAliases
export interface PropertyValueAliases {
  property: string; // The property for which the property value name is used.
  abbreviated_name: string; // An abbreviated name for the property value, or 'n/a' if not available.
  long_name: string; // A long name for the property value.
  additional_aliases: string[]; // Other aliases that may be listed in additional fields.
}

export const PROPERTY_VALUE_ALIASES_FIELDS = [
  "property",
  "abbreviated_name",
  "long_name",
  "additional_aliases"
];

// #endregion

// #region Scripts
export interface Scripts {
  type_name: string; // The name of the type as specified in the Unicode Character Database
}

export const SCRIPTS_FIELDS = [
  "type_name"
];

// #endregion

// #region SpecialCasing
export interface SpecialCasing {
  code: string; // The code point of a character, in hexadecimal form
  lower: string; // The lowercase mapping of the character
  title: string; // The titlecase mapping of the character
  upper: string; // The uppercase mapping of the character
  condition_list: string[]; // Optional list of locale IDs or contexts that override normal behavior
  comment: string; // A comment providing additional information about the entry
}

export const SPECIAL_CASING_FIELDS = [
  "code",
  "lower",
  "title",
  "upper",
  "condition_list",
  "comment"
];

// #endregion

// #region StandardizedVariants
export interface StandardizedVariants {
  variation_sequence: string; // The variation sequence defined in the Unicode Standard.
  description: string; // Description of the desired appearance of the character.
  shaping_environments: string; // Specifies where the appearance is only different in particular shaping environments.
}

export const STANDARDIZED_VARIANTS_FIELDS = [
  "variation_sequence",
  "description",
  "shaping_environments"
];

// #endregion

// #region Unihan
export interface Unihan {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
  joining_type: "R" | "L" | "D" | "C" | "U" | "T"; // Defines the joining type (R = Right_Joining, L = Left_Joining, D = Dual_Joining, C = Join_Causing, U = Non_Joining, T = Transparent)
  joining_group: string; // Defines the joining group, based schematically on character names
}

export const UNIHAN_FIELDS = [
  "code_point",
  "name",
  "joining_type",
  "joining_group"
];

// #endregion

// #region DerivedBidiClass
export interface DerivedBidiClass {
  derived_bidi_class: string; // The derived bidirectional class of a character, indicating its directionality in text.
  date: string; // The date when the data file was generated.
  unicode_character_database: string; // Indicates that this data is part of the Unicode Character Database.
  copyright: string; // Copyright information for the Unicode data.
  terms_of_use: string; // Link to the terms of use for the Unicode data.
  documentation: string; // Link to the documentation for the Unicode Character Database.
}

export const DERIVED_BIDI_CLASS_FIELDS = [
  "derived_bidi_class",
  "date",
  "unicode_character_database",
  "copyright",
  "terms_of_use",
  "documentation"
];

// #endregion

// #region DerivedBinaryProperties
export interface DerivedBinaryProperties {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const DERIVED_BINARY_PROPERTIES_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedCombiningClass
export interface DerivedCombiningClass {
  derived_combining_class: string; // The derived combining class of a character, indicating how it combines with other characters.
}

export const DERIVED_COMBINING_CLASS_FIELDS = [
  "derived_combining_class"
];

// #endregion

// #region DerivedDecompositionType
export interface DerivedDecompositionType {
  type_name: string; // The name of the type as defined in the Unicode Character Database
}

export const DERIVED_DECOMPOSITION_TYPE_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedEastAsianWidth
export interface DerivedEastAsianWidth {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
  joining_type: "R" | "L" | "D" | "C" | "U" | "T"; // Defines the joining type (R = Right_Joining, L = Left_Joining, D = Dual_Joining, C = Join_Causing, U = Non_Joining, T = Transparent)
  joining_group: string; // Defines the joining group, based schematically on character names
}

export const DERIVED_EAST_ASIAN_WIDTH_FIELDS = [
  "code_point",
  "name",
  "joining_type",
  "joining_group"
];

// #endregion

// #region DerivedGeneralCategory
export interface DerivedGeneralCategory {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
  joining_type: "R" | "L" | "D" | "C" | "U" | "T"; // Defines the joining type (R = Right_Joining, L = Left_Joining, D = Dual_Joining, C = Join_Causing, U = Non_Joining, T = Transparent)
  joining_group: string; // Defines the joining group, based schematically on character names
}

export const DERIVED_GENERAL_CATEGORY_FIELDS = [
  "code_point",
  "name",
  "joining_type",
  "joining_group"
];

// #endregion

// #region DerivedJoiningGroup
export interface DerivedJoiningGroup {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const DERIVED_JOINING_GROUP_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedJoiningType
export interface DerivedJoiningType {
  type_name: string; // The name of the type as defined in the Unicode Character Database
}

export const DERIVED_JOINING_TYPE_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedLineBreak
export interface DerivedLineBreak {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const DERIVED_LINE_BREAK_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedNumericType
export interface DerivedNumericType {
  type_name: string; // The name of the derived numeric type
}

export const DERIVED_NUMERIC_TYPE_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedNumericValues
export interface DerivedNumericValues {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
  derived_numeric_value: number; // The derived numeric value associated with the character
}

export const DERIVED_NUMERIC_VALUES_FIELDS = [
  "code_point",
  "name",
  "derived_numeric_value"
];

// #endregion

// #region GraphemeBreakProperty
export interface GraphemeBreakProperty {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
  joining_type: "R" | "L" | "D" | "C" | "U" | "T"; // Defines the joining type (R = Right_Joining, L = Left_Joining, D = Dual_Joining, C = Join_Causing, U = Non_Joining, T = Transparent)
  joining_group: string; // Defines the joining group, based schematically on character names
}

export const GRAPHEME_BREAK_PROPERTY_FIELDS = [
  "code_point",
  "name",
  "joining_type",
  "joining_group"
];

// #endregion

// #region SentenceBreakProperty
export interface SentenceBreakProperty {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
  joining_type: "R" | "L" | "D" | "C" | "U" | "T"; // Defines the joining type (R = Right_Joining, L = Left_Joining, D = Dual_Joining, C = Join_Causing, U = Non_Joining, T = Transparent)
  joining_group: string; // Defines the joining group, based schematically on character names
}

export const SENTENCE_BREAK_PROPERTY_FIELDS = [
  "code_point",
  "name",
  "joining_type",
  "joining_group"
];

// #endregion

// #region WordBreakProperty
export interface WordBreakProperty {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
}

export const WORD_BREAK_PROPERTY_FIELDS = [
  "code_point",
  "name"
];

// #endregion
