// This file is generated by ucd codegen. Do not edit this file directly.
// Unicode Version: 6.3

//#region data-files/v6.3.0/ArabicShaping.txt
/**
 * This interface represents the data structure for Arabic shaping properties.
 */
export interface ArabicShaping {
    /**
     * The code point, in 4-digit hexadecimal form, of an Arabic, Syriac, N'Ko, Mandaic, Mongolian, Phags-pa, or other character.
     * Example: '0629'
     */
    code_point: string;

    /**
     * A short schematic name for that character, descriptive of the shape.
     * Example: 'TEH MARBUTA'
     */
    schematic_name: string;

    /**
     * Defines the joining type, which can be one of the following:
     * - "R" for Right_Joining
     * - "L" for Left_Joining
     * - "D" for Dual_Joining
     * - "C" for Join_Causing
     * - "U" for Non_Joining
     * - "T" for Transparent
     * Example: 'R'
     */
    joining_type: "R" | "L" | "D" | "C" | "U" | "T";

    /**
     * Defines the joining group, based schematically on character names.
     * Example: 'TEH MARBUTA' corresponds to [Joining_Group = Teh_Marbuta].
     */
    joining_group: string;
}

export const ARABIC_SHAPING_FIELDS = [
    "code_point",
    "schematic_name",
    "joining_type",
    "joining_group"
];
//#endregion

//#region data-files/v6.3.0/BidiBrackets.txt
/**
 * BidiBrackets interface represents the mapping of Unicode characters that are treated as bracket pairs by the Unicode Bidirectional Algorithm.
 */
export interface BidiBrackets {
    /**
     * Unicode code point value, represented as a hexadecimal value.
     * Example: "U+0041"
     */
    unicode_code_point: string;

    /**
     * Bidi_Paired_Bracket property value, a code point value or <none>.
     * Example: "U+005B" or "<none>"
     */
    bidi_paired_bracket: string;

    /**
     * Bidi_Paired_Bracket_Type property value, one of the following:
     *   - "o" Open
     *   - "c" Close
     *   - "n" None
     * Example: "o"
     */
    bidi_paired_bracket_type: "o" | "c" | "n";
}

export const BIDI_BRACKETS_FIELDS = [
    "unicode_code_point",
    "bidi_paired_bracket",
    "bidi_paired_bracket_type"
];
//#endregion

//#region data-files/v6.3.0/BidiCharacterTest.txt
/**
 * BidiCharacterTest interface represents a conformance test for implementations of the Unicode Bidirectional Algorithm.
 */
export interface BidiCharacterTest {
    /**
     * A sequence of hexadecimal code point values separated by space.
     * Example: "0041 0052 0061"
     */
    code_point_sequence: string;
    
    /**
     * A value representing the paragraph direction:
     * - 0 represents left-to-right
     * - 1 represents right-to-left
     * - 2 represents auto-LTR according to rules P2 and P3 of the algorithm
     * Example: 0
     */
    paragraph_direction: "0" | "1" | "2";
    
    /**
     * The resolved paragraph embedding level.
     * Example: 0
     */
    resolved_paragraph_embedding_level: number;
    
    /**
     * A list of resolved levels; characters removed in rule X9 are indicated with an 'x'.
     * Example: "0 1 x 2"
     */
    resolved_levels: string;
    
    /**
     * A list of indices showing the resulting visual ordering from left to right; characters with a resolved level of 'x' are skipped.
     * Example: "0 1 3"
     */
    visual_ordering_indices: string;
}

export const BIDI_CHARACTER_TEST_FIELDS = [
    "code_point_sequence",
    "paragraph_direction",
    "resolved_paragraph_embedding_level",
    "resolved_levels",
    "visual_ordering_indices"
];
//#endregion

//#region data-files/v6.3.0/BidiMirroring.txt
/**
 * This interface represents the Bidi_Mirroring_Glyph property mappings in Unicode.
 */
export interface BidiMirroring {
    /**
     * The code point of the original character that has a mirrored glyph.
     * It is represented as a variable-length hexadecimal value with 4 to 6 digits.
     * Example: '0041' for 'A'.
     */
    original_code_point: string;

    /**
     * The code point of the mirrored character.
     * It is represented as a variable-length hexadecimal value with 4 to 6 digits.
     * Example: '0061' for 'a'.
     */
    mirrored_code_point: string;

    /**
     * A comment indicating the mirroring fit.
     * This may include notes on the appropriateness of the mirroring.
     * Example: 'BEST FIT'.
     */
    comment?: string;
}

export const BIDI_MIRRORING_FIELDS = [
    "original_code_point",
    "mirrored_code_point",
    "comment"
];
//#endregion

//#region data-files/v6.3.0/BidiTest.txt
/**
 * This interface defines the structure for the BidiTest conformance test data.
 */
export interface BidiTest {
    /**
     * A Levels line indicates that all following data lines, up to the next Levels line,
     * have the same resulting ordering levels.
     * Format: @Levels: <levels>
     * Example: @Levels: 1 0
     */
    levels: string;

    /**
     * A Reorder line indicates that all following data lines, up to the next Reorder line,
     * have the same resulting reordering.
     * Format: @Reorder: <ordering>
     * Example: @Reorder: 1 0
     */
    reorder: string;

    /**
     * A data line has the following format: <input> ; <bitset>
     * <input> = An ordered list of BIDI property values
     * <bitset> = A hex bitset for paragraph levels (P): 1 = auto-LTR, 2 = LTR, 4 = RTL
     * Example: L LRE R R; 7
     */
    data: string;
}

export const BIDI_TEST_FIELDS = [
    "levels",
    "reorder",
    "data"
];
//#endregion

//#region data-files/v6.3.0/Blocks.txt
/**
 * Interface representing Unicode Character Database blocks.
 */
export interface Blocks {
    /**
     * The starting code point of the block, represented as a hexadecimal value.
     * Example: "0000"
     */
    start_code: string;

    /**
     * The ending code point of the block, represented as a hexadecimal value.
     * Example: "007F"
     */
    end_code: string;

    /**
     * The name of the block, which may contain spaces and is case-insensitive.
     * Example: "Basic Latin"
     */
    block_name: string;
}

export const BLOCKS_FIELDS = [
    "start_code",
    "end_code",
    "block_name"
];
//#endregion

//#region data-files/v6.3.0/CJKRadicals.txt
/**
 * Interface representing the mapping from radical numbers to characters in the CJK Radicals.
 */
export interface CJKRadicals {
    /**
     * The radical number, which matches the regular expression [1-9][0-9]{0,2}'?
     * Example: "1", "2'"
     */
    radical_number: string;

    /**
     * The CJK radical character corresponding to the radical number.
     * Example: "氵"
     */
    cjk_radical_character: string;

    /**
     * The CJK unified ideograph formed from the radical.
     * Example: "水"
     */
    cjk_unified_ideograph: string;
}

export const CJK_RADICALS_FIELDS = [
    "radical_number",
    "cjk_radical_character",
    "cjk_unified_ideograph"
];
//#endregion

//#region data-files/v6.3.0/CaseFolding.txt
/**
 * This interface represents the case folding properties as defined in the Unicode Character Database.
 */
export interface CaseFolding {
    /**
     * The Unicode code point of the character.
     * Format: Hexadecimal (e.g., U+0041 for 'A').
     */
    code: string;

    /**
     * The status of the case folding mapping.
     * Possible values: "C" (common), "F" (full), "S" (simple), "T" (Turkic special case).
     */
    status: "C" | "F" | "S" | "T";

    /**
     * The mapping for case folding.
     * Format: A string of characters or multiple characters separated by spaces.
     * Example: "a" for simple case folding, "ß" for full case folding.
     */
    mapping: string;

    /**
     * The name of the character.
     * This is a descriptive name for the character represented by the code point.
     */
    name: string;
}

export const CASE_FOLDING_FIELDS = [
    "code",
    "status",
    "mapping",
    "name"
];
//#endregion

//#region data-files/v6.3.0/CompositionExclusions.txt
/**
 * This interface represents the Composition Exclusion Table defined in UAX #15, Unicode Normalization Forms.
 *
 * @property {string} character - The character that is excluded from composition.
 * @property {string} reason - The reason for the exclusion, which may include specific conditions or categories.
 */
export interface CompositionExclusions {
  character: string;
  reason: string;
}

export const COMPOSITION_EXCLUSIONS_FIELDS = [
  "character",
  "reason"
];
//#endregion

//#region data-files/v6.3.0/DerivedAge.txt
/**
 * This interface represents the derived properties of Unicode characters, detailing when various code points were first assigned.
 */
export interface DerivedAge {
    /**
     * The date when the code point was assigned.
     * Format: YYYY-MM-DD, HH:MM:SS GMT
     * Example: "2013-08-27, 18:11:46 GMT"
     */
    assigned_date: string;

    /**
     * The version of Unicode when the code point was assigned.
     * Format: Major.Minor.Patch
     * Example: "6.3.0"
     */
    unicode_version: string;

    /**
     * Indicates the type of code point assigned.
     * Possible values: "graphic", "format", "control", "private-use", "surrogate", "noncharacter"
     */
    code_point_type: "graphic" | "format" | "control" | "private-use" | "surrogate" | "noncharacter";

    /**
     * Additional notes regarding the assignment of the code point.
     */
    notes: string;
}

export const DERIVED_AGE_FIELDS = [
    "assigned_date",
    "unicode_version",
    "code_point_type",
    "notes"
];
//#endregion

//#region data-files/v6.3.0/DerivedCoreProperties.txt
/**
 * Interface representing the derived core properties from the Unicode Character Database.
 */
export interface DerivedCoreProperties {
    /**
     * The Unicode character's general category.
     * Example: "Lu" for uppercase letters.
     */
    general_category: "Lu" | "Ll" | "Lt" | "Lm" | "Lo" | "Mn" | "Mc" | "Me" | "Nd" | "Nl" | "No" | "Pc" | "Pd" | "Ps" | "Pe" | "Pi" | "Pf" | "Po" | "Sm" | "Sc" | "Sk" | "So" | "Zs" | "Zl" | "Zp";

    /**
     * The Unicode character's script.
     * Example: "Latn" for Latin script.
     */
    script: "Latn" | "Cyrl" | "Grek" | "Hebr" | "Arab" | "Hani" | "Hans" | "Hant" | "Jpan" | "Kore" | "Thai" | "Beng" | "Gujr" | "Gurm" | "Knda" | "Mlym" | "Orya" | "Taml" | "Telu" | "Tirh" | "Sinh" | "Mymr" | "Tibt" | "Yiii" | "Cher" | "Copt" | "Glag" | "Runr" | "Ogam" | "Phnx" | "Hira" | "Kana" | "Bopo" | "Yiii";

    /**
     * The Unicode character's numeric value, if applicable.
     * Example: 1.0 for the character '1'.
     */
    numeric_value?: number;

    /**
     * The Unicode character's bidirectional category.
     * Example: "L" for left-to-right.
     */
    bidi_category: "L" | "R" | "AL" | "EN" | "ES" | "ET" | "AN" | "CS" | "NSM" | "B";

    /**
     * The Unicode character's combining class.
     * Example: 0 for base characters.
     */
    combining_class: number;
}

export const DERIVED_CORE_PROPERTIES_FIELDS = [
    "general_category",
    "script",
    "numeric_value",
    "bidi_category",
    "combining_class"
];
//#endregion

//#region data-files/v6.3.0/DerivedNormalizationProps.txt
/**
 * Interface representing the derived normalization properties.
 */
export interface DerivedNormalizationProps {
    /**
     * The normalization form, which can be one of the following: "NFC", "NFD", "NFKC", "NFKD".
     * Example: "NFC"
     */
    normalization_form: "NFC" | "NFD" | "NFKC" | "NFKD";

    /**
     * A boolean indicating whether to use compatibility normalization.
     * Example: true
     */
    use_compatibility: boolean;

    /**
     * The version of the normalization algorithm used.
     * Example: "6.3.0"
     */
    version: string;

    /**
     * A description of the normalization properties.
     * Example: "Normalization properties for Unicode 6.3.0"
     */
    description: string;
}

export const DERIVED_NORMALIZATION_PROPS_FIELDS = [
    "normalization_form",
    "use_compatibility",
    "version",
    "description"
];
//#endregion

//#region data-files/v6.3.0/EastAsianWidth.txt
/**
 * EastAsianWidth
 *
 * This interface represents the East Asian Width properties for Unicode characters.
 * Each character is associated with a Unicode value and its corresponding East Asian Width property.
 *
 * The East Asian Width property can take one of the following values:
 * - "N": Not East Asian
 * - "A": Ambiguous
 * - "H": Half-width
 * - "W": Full-width
 * - "F": Full-width (for compatibility)
 * - "Na": Not applicable
 *
 * All code points not explicitly listed are given the value "N".
 *
 * For more information, see UAX #11: East Asian Width,
 * at http://www.unicode.org/reports/tr11/
 */
export interface EastAsianWidth {
    /**
     * The Unicode value of the character.
     * Format: U+XXXX (where XXXX is a hexadecimal value)
     */
    unicode_value: string;

    /**
     * The East Asian Width property of the character.
     * Possible values: "N", "A", "H", "W", "F", "Na"
     */
    east_asian_width: "N" | "A" | "H" | "W" | "F" | "Na";
}

export const EAST_ASIAN_WIDTH_FIELDS = [
    "unicode_value",
    "east_asian_width"
];
//#endregion

//#region data-files/v6.3.0/EmojiSources.txt
/**
 * This interface represents the mappings between Unicode code points and Shift-JIS codes for cell phone carrier symbols.
 * Each mapping is symmetric for equivalent Unicode and carrier symbols or sequences.
 */
export interface EmojiSources {
    /**
     * Unicode code point or sequence.
     * Example: U+1F600
     */
    unicode_code_point_or_sequence: string;

    /**
     * DoCoMo Shift-JIS code.
     * This field contains a code if and only if the DoCoMo character set has a symbol which is equivalent to the Unicode character or sequence.
     */
    docomo_shift_jis_code?: string;

    /**
     * KDDI Shift-JIS code.
     * This field contains a code if and only if the KDDI character set has a symbol which is equivalent to the Unicode character or sequence.
     */
    kddi_shift_jis_code?: string;

    /**
     * SoftBank Shift-JIS code.
     * This field contains a code if and only if the SoftBank character set has a symbol which is equivalent to the Unicode character or sequence.
     */
    softbank_shift_jis_code?: string;
}

export const EMOJI_SOURCES_FIELDS = [
    "unicode_code_point_or_sequence",
    "docomo_shift_jis_code",
    "kddi_shift_jis_code",
    "softbank_shift_jis_code"
];
//#endregion

//#region data-files/v6.3.0/HangulSyllableType.txt
/**
 * Interface representing the Hangul Syllable Type data.
 */
export interface HangulSyllableType {
    /**
     * The Hangul syllable type code.
     * Format: "HANGUL_SYLLABLE_TYPE_CODE"
     * Example: "L"
     */
    hangul_syllable_type_code: "L" | "V" | "LV" | "LVT";

    /**
     * The description of the syllable type.
     * Format: string
     * Example: "Leading consonant"
     */
    description: string;

    /**
     * The Unicode value of the syllable type.
     * Format: integer
     * Example: 0x1100
     */
    unicode_value: number;
}

export const HANGUL_SYLLABLE_TYPE_FIELDS = [
    "hangul_syllable_type_code",
    "description",
    "unicode_value"
];
//#endregion

//#region data-files/v6.3.0/IndicMatraCategory.txt
/**
 * This interface defines the provisional property for Indic Matra Categories.
 *
 * The Indic_Matra_Category is an enumerated property that specifies the
 * syllabic structure for Indic scripts. It is primarily designed to supplement
 * the Indic_Syllabic_Category property.
 *
 * Note: This property is provisional and may change in future versions.
 */
export interface IndicMatraCategory {
    /**
     * Code Point or Code Point Range
     *
     * This field represents the Unicode code point or a range of code points
     * for the characters associated with the Indic Matra Category.
     * Example: "U+0900" or "U+0900-U+090F"
     */
    code_point: string;

    /**
     * Indic Matra Category
     *
     * This field indicates the category of the matra associated with the
     * code point. The value can be one of the following:
     * - "dependent_vowel"
     * - "virama"
     *
     * Example: "dependent_vowel"
     */
    indic_matra_category: "dependent_vowel" | "virama";
}

export const INDIC_MATRA_CATEGORY_FIELDS = [
    "code_point",
    "indic_matra_category"
];
//#endregion

//#region data-files/v6.3.0/IndicSyllabicCategory.txt
/**
 * This interface defines the Indic Syllabic Category property for Unicode characters.
 *
 * The Indic_Syllabic_Category is an enumerated property that categorizes characters in Indic scripts
 * based on their syllabic structure and segmentation rules. This property is provisional and may change
 * in future versions of the Unicode Character Database.
 *
 * The following scripts are assessed as Indic: Devanagari, Bengali, Gurmukhi, Gujarati, Oriya, Tamil,
 * Telugu, Kannada, Malayalam, Sinhala, Thai, Lao, Tibetan, Myanmar, Tagalog, Hanunoo, Buhid,
 * Tagbanwa, Khmer, Limbu, Tai Le, New Tai Lue, Buginese, Tai Tham, Balinese, Sundanese, Batak,
 * Lepcha, Syloti Nagri, Phags-Pa, Saurashtra, Kayah Li, Rejang, Javanese, Cham, Tai Viet,
 * Meetei Mayek, Kharoshthi, Brahmi, Kaithi, Chakma, Sharada, Takri.
 *
 * All characters for scripts not listed take the default value for this property unless individually listed.
 */
export interface IndicSyllabicCategory {
    /**
     * The code point or code point range of the character.
     * Format: U+XXXX or U+XXXX..U+YYYY
     * Example: U+0A15 or U+0A15..U+0A1A
     */
    code_point: string;

    /**
     * The Indic Syllabic Category of the character.
     * Possible values include:
     * - "Vowel"
     * - "Consonant"
     * - "Vowel_Consonant"
     * - "Consonant_Cluster"
     * - "Other"
     * Example: "Vowel"
     */
    indic_syllabic_category: "Vowel" | "Consonant" | "Vowel_Consonant" | "Consonant_Cluster" | "Other";
}

export const INDIC_SYLLABIC_CATEGORY_FIELDS = [
    "code_point",
    "indic_syllabic_category"
];
//#endregion

//#region data-files/v6.3.0/Jamo.txt
/**
 * Interface representing the Jamo_Short_Name property.
 */
export interface Jamo {
    /**
     * The code point of a conjoining jamo character in 4-digit hexadecimal form.
     * Example: '1100'
     */
    code_point: string;

    /**
     * The Jamo_Short_Name as a one-, two-, or three-character ASCII string.
     * Example: 'G', 'GG', 'N'
     */
    jamo_short_name: string;
}

export const JAMO_FIELDS = ["code_point", "jamo_short_name"];
//#endregion

//#region data-files/v6.3.0/LineBreak.txt
/**
 * This interface represents the line break properties for Unicode characters.
 *
 * Each entry consists of a Unicode value and its corresponding line break property.
 * The line break property can be one of the following:
 * - Normative: "BK", "CR", "LF", "CM", "SG", "GL", "CB", "SP", "ZW", "NL", "WJ", "JL", "JV", "JT", "H2", "H3"
 * - Informative: "XX", "OP", "CL", "CP", "QU", "NS", "EX", "SY", "IS", "PR", "PO", "NU", "AL", "ID", "IN", "HY", "BB", "BA", "SA", "AI", "B2", "HL", "CJ", "RI"
 *
 * All code points not explicitly listed are given the value "XX".
 * Unassigned code points default to "ID" or "PR" based on specific ranges.
 *
 * For more information, refer to UAX #14: Unicode Line Breaking Algorithm.
 */
export interface LineBreak {
    unicode_value: string;
    line_break_property: "BK" | "CR" | "LF" | "CM" | "SG" | "GL" | "CB" | "SP" | "ZW" | "NL" | "WJ" | "JL" | "JV" | "JT" | "H2" | "H3" | "XX" | "OP" | "CL" | "CP" | "QU" | "NS" | "EX" | "SY" | "IS" | "PR" | "PO" | "NU" | "AL" | "ID" | "IN" | "HY" | "BB" | "BA" | "SA" | "AI" | "B2" | "HL" | "CJ" | "RI";
}

export const LINE_BREAK_FIELDS = [
    "unicode_value",
    "line_break_property"
];
//#endregion

//#region data-files/v6.3.0/NameAliases.txt
/**
 * This interface defines the formal name aliases for Unicode characters.
 */
export interface NameAliases {
  /**
   * The code point of the Unicode character, represented as a hexadecimal string.
   * Example: "U+0041" for the character 'A'.
   */
  code_point: string;

  /**
   * The alias for the Unicode character, which can be a correction, control, alternate, figment, or abbreviation.
   * Example: "LATIN CAPITAL LETTER A".
   */
  alias: string;

  /**
   * The type of the alias, which can be one of the following: "correction", "control", "alternate", "figment", "abbreviation".
   * Example: "control" for control characters.
   */
  type: "correction" | "control" | "alternate" | "figment" | "abbreviation";
}

export const NAME_ALIASES_FIELDS = [
  "code_point",
  "alias",
  "type"
];
//#endregion

//#region data-files/v6.3.0/NamedSequences.txt
/**
 * Interface representing named sequences in Unicode Character Database.
 */
export interface NamedSequences {
    /**
     * The name of the sequence.
     * Example: "EXAMPLE NAME"
     */
    name: string;
    /**
     * The code point sequence for USI, represented as a string of space-separated values.
     * Example: "1000 1001 1002"
     */
    code_point_sequence: string;
}

export const NAMED_SEQUENCES_FIELDS = [
    "name",
    "code_point_sequence"
];
//#endregion

//#region data-files/v6.3.0/NamedSequencesProv.txt
/**
 * Interface representing the provisional named sequences from the Unicode Character Database.
 */
export interface NamedSequencesProv {
  /**
   * The name of the sequence.
   */
  name: string;
  /**
   * The code point sequence represented as a string of space-separated values.
   * Example: "1000 1001 1002"
   */
  code_point_sequence: string;
}

export const NAMED_SEQUENCES_PROV_FIELDS = [
  "name",
  "code_point_sequence"
];
//#endregion

//#region data-files/v6.3.0/NormalizationCorrections.txt
/**
 * This interface represents the normalization corrections data as specified in the Unicode Character Database.
 */
export interface NormalizationCorrections {
    /**
     * Unicode code point, represented as a hexadecimal string (e.g., "U+0041").
     */
    unicode_code_point: string;
    /**
     * Original (erroneous) decomposition of the character.
     */
    original_decomposition: string;
    /**
     * Corrected decomposition of the character.
     */
    corrected_decomposition: string;
    /**
     * Version of Unicode for which the correction was entered, in n.n.n format (e.g., "6.3.0").
     */
    unicode_version: string;
    /**
     * Indicates the Unicode Corrigendum which documents the correction.
     */
    comment: string;
}

export const NORMALIZATION_CORRECTIONS_FIELDS = [
    "unicode_code_point",
    "original_decomposition",
    "corrected_decomposition",
    "unicode_version",
    "comment"
];
//#endregion

//#region data-files/v6.3.0/NormalizationTest.txt
/**
 * Interface representing the normalization test suite data.
 */
export interface NormalizationTest {
    /**
     * The source code points to be normalized.
     * Example: "U+0041; U+0061"
     */
    source: string;
    /**
     * The normalized form in NFC (Normalization Form C).
     * Example: "U+0041"
     */
    nfc: string;
    /**
     * The normalized form in NFD (Normalization Form D).
     * Example: "U+0041"
     */
    nfd: string;
    /**
     * The normalized form in NFKC (Normalization Form KC).
     * Example: "U+0041"
     */
    nfkc: string;
    /**
     * The normalized form in NFKD (Normalization Form KD).
     * Example: "U+0041"
     */
    nfkd: string;
}

export const NORMALIZATION_TEST_FIELDS = [
    "source",
    "nfc",
    "nfd",
    "nfkc",
    "nfkd"
];
//#endregion

//#region data-files/v6.3.0/PropList.txt
/**
 * Interface representing the Unicode Character Database properties.
 */
export interface PropList {
    /**
     * The date when the data was last updated.
     * Format: "YYYY-MM-DD HH:MM:SS GMT"
     * Example: "2013-09-25 18:58:50 GMT"
     */
    date: string;

    /**
     * The version of the PropList.
     * Format: "X.Y.Z"
     * Example: "6.3.0"
     */
    version: string;

    /**
     * The copyright information for the Unicode Character Database.
     * Example: "Copyright (c) 1991-2013 Unicode, Inc."
     */
    copyright: string;

    /**
     * The terms of use for the Unicode Character Database.
     * Example: "For terms of use, see http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;

    /**
     * The documentation link for the Unicode Character Database.
     * Example: "For documentation, see http://www.unicode.org/reports/tr44/"
     */
    documentation: string;
}

export const PROP_LIST_FIELDS = [
    "date",
    "version",
    "copyright",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v6.3.0/PropertyAliases.txt
/**
 * This interface defines the property aliases used in the Unicode Character Database (UCD).
 * The aliases can be used for XML formats of UCD data, regular-expression property tests,
 * and other programmatic textual descriptions of Unicode data.
 *
 * Each property has an abbreviated name, a long name, and may have additional aliases.
 *
 * Note: Property value names are not unique across properties, and some property names may
 * be the same as property value names. The combination of property value and property name
 * is unique.
 */
export interface PropertyAliases {
    /**
     * Abbreviated name for the property.
     */
    abbreviated_name: string;

    /**
     * Long name for the property.
     */
    long_name: string;

    /**
     * Additional aliases for the property, if any.
     */
    additional_aliases?: string[];
}

export const PROPERTY_ALIASES_FIELDS = [
    "abbreviated_name",
    "long_name",
    "additional_aliases"
];
//#endregion

//#region data-files/v6.3.0/PropertyValueAliases.txt
/**
 * This interface represents the property value aliases used in the Unicode Character Database (UCD).
 * Each property value name is associated with a specific property and may have multiple aliases.
 *
 * The structure of each entry includes:
 * - `property_name`: The name of the property for which the value is used (e.g., `Bidi_Class`).
 * - `abbreviated_name`: A short form of the property value name (e.g., `AL`).
 * - `long_name`: A detailed description of the property value (e.g., `Arabic Letter`).
 *
 * For certain properties like `ccc`, there may be additional fields:
 * - `numeric`: A numeric representation of the property value.
 * - `abbreviated`: An abbreviated form of the property value.
 * - `long`: A long description of the property value.
 *
 * Note: Property value names are not unique across properties, and loose matching should be applied to property names and values.
 */
export interface PropertyValueAliases {
    property_name: string;
    abbreviated_name: string;
    long_name: string;
    numeric?: number;
    abbreviated?: string;
    long?: string;
}

export const PROPERTY_VALUE_ALIASES_FIELDS = [
    "property_name",
    "abbreviated_name",
    "long_name",
    "numeric",
    "abbreviated",
    "long"
];
//#endregion

//#region data-files/v6.3.0/ScriptExtensions.txt
/**
 * Interface representing the Script Extensions data from Unicode Character Database.
 */
export interface ScriptExtensions {
    /**
     * The code point in hexadecimal format. Example: "U+0041" for 'A'.
     */
    code_point: string;
    /**
     * The script property value(s) associated with the code point. Example: "Latin", "Cyrillic".
     */
    script: string | string[];
}

export const SCRIPT_EXTENSIONS_FIELDS = [
    "code_point",
    "script"
];
//#endregion

//#region data-files/v6.3.0/Scripts.txt
/**
 * Interface representing the Unicode Character Database.
 */
export interface UnicodeCharacterDatabase {
    /**
     * The date when the database was created or last modified.
     * Format: "YYYY-MM-DD HH:MM:SS GMT"
     * Example: "2013-07-05 14:09:02 GMT"
     */
    date: string;

    /**
     * The version of the Unicode Character Database.
     * Format: "X.X.X"
     * Example: "6.3.0"
     */
    version: string;

    /**
     * The copyright information for the database.
     * Example: "Copyright (c) 1991-2013 Unicode, Inc."
     */
    copyright: string;

    /**
     * The terms of use for the database.
     * Example: "For terms of use, see http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;

    /**
     * The documentation link for the database.
     * Example: "For documentation, see http://www.unicode.org/reports/tr44/"
     */
    documentation: string;
}

export const UNICODE_CHARACTER_DATABASE_FIELDS = [
    "date",
    "version",
    "copyright",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v6.3.0/SpecialCasing.txt
/**
 * This interface represents the special casing properties of Unicode characters.
 */
export interface SpecialCasing {
    /**
     * The Unicode code point of the character in hexadecimal format.
     * Example: "0041" for 'A'
     */
    code: string;

    /**
     * The lowercase mapping of the character in hexadecimal format.
     * Example: "0061" for 'a'
     */
    lower: string;

    /**
     * The titlecase mapping of the character in hexadecimal format.
     * Example: "0041" for 'A'
     */
    title: string;

    /**
     * The uppercase mapping of the character in hexadecimal format.
     * Example: "0041" for 'A'
     */
    upper: string;

    /**
     * An optional list of conditions that must be met for the mappings to apply.
     * Example: "en-US Not_uppercase"
     */
    condition_list?: string;

    /**
     * A comment providing additional information about the mapping.
     * Example: "Commonly used in English."
     */
    comment?: string;
}

export const SPECIAL_CASING_FIELDS = [
    "code",
    "lower",
    "title",
    "upper",
    "condition_list",
    "comment"
];
//#endregion

//#region data-files/v6.3.0/StandardizedVariants.txt
/**
 * Interface representing standardized variation sequences as defined in the Unicode Standard.
 */
export interface StandardizedVariants {
  /**
   * The variation sequence.
   * Example: "U+E0100 U+E0101"
   */
  variation_sequence: string;

  /**
   * The description of the desired appearance.
   * Example: "This character appears as a bold version."
   */
  description: string;

  /**
   * Indicates where the appearance is only different in particular shaping environments.
   * Example: "This appearance is only different in a specific font."
   */
  shaping_environments: string;
}

export const STANDARDIZED_VARIANTS_FIELDS = [
  "variation_sequence",
  "description",
  "shaping_environments"
];
//#endregion

//#region data-files/v6.3.0/USourceData.txt
/**
 * Interface representing the basic data for U-source ideographs.
 */
export interface USourceData {
    /**
     * The U-source ID.
     * Example: "U+1234"
     */
    u_source_id: string;

    /**
     * Text indicating the ideograph's status.
     * Possible values: "C" (Included in Extension C), "D" (Included in Extension D), "E" (Included for Extension E).
     * Example: "C"
     */
    status: "C" | "D" | "E";
}

export const USOURCE_DATA_FIELDS = [
    "u_source_id",
    "status"
];
//#endregion

//#region data-files/v6.3.0/extracted/DerivedBidiClass.txt
/**
 * Interface representing the Unicode Character Database derived from the file DerivedBidiClass.
 */
export interface DerivedBidiClass {
    /**
     * The character code point in hexadecimal format.
     * Example: "U+0041" for the character 'A'.
     */
    code_point: string;

    /**
     * The bidirectional category of the character.
     * Example: "L" for Left-to-Right, "R" for Right-to-Left.
     */
    bidi_category: "L" | "R" | "AL" | "EN" | "ES" | "ET" | "AN" | "CS" | "NSM" | "B" | "S" | "WS" | "ON";

    /**
     * The mirrored character if applicable.
     * Example: "U+00AB" for the left-pointing double angle quotation mark.
     */
    mirrored: string | null;

    /**
     * The numeric value of the character if it is a number.
     * Example: 1.0 for the character '1'.
     */
    numeric_value: number | null;

    /**
     * The directionality of the character.
     * Example: "LTR" for left-to-right, "RTL" for right-to-left.
     */
    directionality: "LTR" | "RTL";
}

export const DERIVED_BIDI_CLASS_FIELDS = [
    "code_point",
    "bidi_category",
    "mirrored",
    "numeric_value",
    "directionality"
];
//#endregion

//#region data-files/v6.3.0/extracted/DerivedBinaryProperties.txt
/**
 * Interface representing the derived binary properties from the Unicode Character Database.
 */
export interface DerivedBinaryProperties {
    /**
     * Indicates whether the character is a control character.
     * Example: "true" or "false"
     */
    control: "true" | "false";

    /**
     * Indicates whether the character is a private use character.
     * Example: "true" or "false"
     */
    private_use: "true" | "false";

    /**
     * Indicates whether the character is a surrogate.
     * Example: "true" or "false"
     */
    surrogate: "true" | "false";

    /**
     * Indicates whether the character is a non-character.
     * Example: "true" or "false"
     */
    non_character: "true" | "false";

    /**
     * Indicates whether the character is a deprecated character.
     * Example: "true" or "false"
     */
    deprecated: "true" | "false";

    /**
     * Indicates whether the character is a grapheme base.
     * Example: "true" or "false"
     */
    grapheme_base: "true" | "false";

    /**
     * Indicates whether the character is a grapheme extender.
     * Example: "true" or "false"
     */
    grapheme_extender: "true" | "false";

    /**
     * Indicates whether the character is a variation selector.
     * Example: "true" or "false"
     */
    variation_selector: "true" | "false";

    /**
     * Indicates whether the character is a join control character.
     * Example: "true" or "false"
     */
    join_control: "true" | "false";

    /**
     * Indicates whether the character is a non-spacing mark.
     * Example: "true" or "false"
     */
    non_spacing_mark: "true" | "false";

    /**
     * Indicates whether the character is a combining character.
     * Example: "true" or "false"
     */
    combining: "true" | "false";

    /**
     * Indicates whether the character is a whitespace character.
     * Example: "true" or "false"
     */
    whitespace: "true" | "false";
}

export const DERIVED_BINARY_PROPERTIES_FIELDS = [
    "control",
    "private_use",
    "surrogate",
    "non_character",
    "deprecated",
    "grapheme_base",
    "grapheme_extender",
    "variation_selector",
    "join_control",
    "non_spacing_mark",
    "combining",
    "whitespace"
];
//#endregion

//#region data-files/v6.3.0/extracted/DerivedCombiningClass.txt
/**
 * Interface representing the Unicode Character Database derived combining class.
 */
export interface DerivedCombiningClass {
    /**
     * The canonical combining class value, which is a non-negative integer.
     * Example: 0, 1, 2, ...
     */
    canonical_combining_class: number;

    /**
     * The name of the character, represented as a string.
     * Example: "COMBINING GRAVE ACCENT"
     */
    character_name: string;

    /**
     * The Unicode code point of the character, represented as a string.
     * Example: "U+0300"
     */
    code_point: string;

    /**
     * The decomposition mapping, which may be a string or an array of strings.
     * Example: "U+0061 U+0300" or ["U+0061", "U+0300"]
     */
    decomposition_mapping: string | string[];

    /**
     * The character's bidirectional category, represented as a string.
     * Example: "ON"
     */
    bidi_category: string;

    /**
     * The character's script, represented as a string.
     * Example: "Latin"
     */
    script: string;
}

export const DERIVED_COMBINING_CLASS_FIELDS = [
    "canonical_combining_class",
    "character_name",
    "code_point",
    "decomposition_mapping",
    "bidi_category",
    "script"
];
//#endregion

//#region data-files/v6.3.0/extracted/DerivedDecompositionType.txt
/**
 * Interface representing the Unicode Character Database derived decomposition type.
 */
export interface DerivedDecompositionType {
    /**
     * The decomposition mapping for the character.
     * Example: "<decomposition mapping>"
     */
    decomposition_mapping: string;

    /**
     * The character's canonical combining class.
     * Example: 0 (for not a combining character)
     */
    canonical_combining_class: number;

    /**
     * The character's bidirectional category.
     * Example: "L" (for Left-to-Right)
     */
    bidirectional_category: "L" | "R" | "AL" | "EN" | "ES" | "ET" | "AN" | "CS" | "NSM" | "B" | "S" | "WS" | "ON";

    /**
     * The character's general category.
     * Example: "Lu" (for Uppercase Letter)
     */
    general_category: "Lu" | "Ll" | "Lt" | "Lm" | "Lo" | "Mn" | "Mc" | "Me" | "Nd" | "Nl" | "No" | "Pc" | "Pd" | "Ps" | "Pe" | "Pi" | "Pf" | "Po" | "Sm" | "Sc" | "Sk" | "So" | "Zs" | "Zl" | "Zp";

    /**
     * The character's numeric value, if applicable.
     * Example: 1.5
     */
    numeric_value?: number;
}

export const DERIVED_DECOMPOSITION_TYPE_FIELDS = [
    "decomposition_mapping",
    "canonical_combining_class",
    "bidirectional_category",
    "general_category",
    "numeric_value"
];
//#endregion

//#region data-files/v6.3.0/extracted/DerivedEastAsianWidth.txt
/**
 * Interface representing the Derived East Asian Width data.
 */
export interface DerivedEastAsianWidth {
    /**
     * The Unicode character code point in hexadecimal format.
     * Example: "U+0041" for the character 'A'.
     */
    code_point: string;

    /**
     * The East Asian Width property of the character.
     * Possible values: "N", "A", "H", "W", "F", "P".
     * Example: "W" for wide characters.
     */
    east_asian_width: "N" | "A" | "H" | "W" | "F" | "P";
}

export const DERIVED_EAST_ASIAN_WIDTH_FIELDS = [
    "code_point",
    "east_asian_width"
];
//#endregion

//#region data-files/v6.3.0/extracted/DerivedGeneralCategory.txt
/**
 * Interface representing the Unicode Character Database derived general category.
 */
export interface DerivedGeneralCategory {
    /**
     * The general category of the character.
     * Example: "Lu" for uppercase letters.
     */
    general_category: "Lu" | "Ll" | "Lt" | "Lm" | "Lo" | "Mn" | "Mc" | "Me" | "Nd" | "Nl" | "No" | "Pc" | "Pd" | "Ps" | "Pe" | "Pi" | "Pf" | "Po" | "Sm" | "Sc" | "Sk" | "So" | "Zs" | "Zl" | "Zp";

    /**
     * The numeric value associated with the character, if applicable.
     * Example: 1.0 for a character with a numeric value.
     */
    numeric_value?: number;

    /**
     * The name of the character in Unicode.
     * Example: "LATIN CAPITAL LETTER A".
     */
    character_name: string;

    /**
     * The code point of the character in hexadecimal format.
     * Example: "0041" for 'A'.
     */
    code_point: string;
}

export const DERIVED_GENERAL_CATEGORY_FIELDS = [
    "general_category",
    "numeric_value",
    "character_name",
    "code_point"
];
//#endregion

//#region data-files/v6.3.0/extracted/DerivedJoiningGroup.txt
/**
 * Interface representing the DerivedJoiningGroup data structure.
 */
export interface DerivedJoiningGroup {
    /**
     * The unique identifier for the joining group.
     * Format: string
     * Example: "U+0041"
     */
    joining_group_id: string;

    /**
     * The name of the joining group.
     * Format: string
     * Example: "Left"
     */
    joining_group_name: string;

    /**
     * The type of joining group.
     * Union type: "L", "R", "D"
     * Example: "L"
     */
    joining_group_type: "L" | "R" | "D";

    /**
     * The description of the joining group.
     * Format: string
     * Example: "This group includes characters that join to the left."
     */
    description: string;
}

export const DERIVED_JOINING_GROUP_FIELDS = [
    "joining_group_id",
    "joining_group_name",
    "joining_group_type",
    "description"
];
//#endregion

//#region data-files/v6.3.0/extracted/DerivedJoiningType.txt
/**
 * Interface representing the Unicode Character Database derived joining type.
 */
export interface DerivedJoiningType {
    /**
     * The character that represents the joining type.
     * Example: "U+0020"
     */
    joining_character: string;
    /**
     * The type of joining.
     * Example: "U+0020"
     */
    joining_type: "U+0020" | "U+0021" | "U+0022";
    /**
     * The direction of joining.
     * Example: "left" or "right"
     */
    joining_direction: "left" | "right";
}

export const DERIVED_JOINING_TYPE_FIELDS = [
    "joining_character",
    "joining_type",
    "joining_direction"
];
//#endregion

//#region data-files/v6.3.0/extracted/DerivedLineBreak.txt
/**
 * Interface representing the DerivedLineBreak data structure.
 */
export interface DerivedLineBreak {
    /**
     * The date of the data entry in ISO 8601 format.
     * Example: "2013-07-05T14:08:46Z"
     */
    date: string;
    /**
     * The source of the Unicode Character Database.
     * Example: "Unicode, Inc."
     */
    source: string;
    /**
     * The terms of use URL for the Unicode data.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;
    /**
     * The documentation URL for the Unicode data.
     * Example: "http://www.unicode.org/reports/tr44/"
     */
    documentation: string;
}

export const DERIVED_LINE_BREAK_FIELDS = [
    "date",
    "source",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v6.3.0/extracted/DerivedNumericType.txt
/**
 * Interface representing the DerivedNumericType from the Unicode Character Database.
 */
export interface DerivedNumericType {
    /**
     * The numeric value associated with the character.
     * Example: 1.0
     */
    numeric_value: number;
    
    /**
     * The type of numeric value.
     * Can be one of the following: "decimal", "digit", "numeric".
     */
    numeric_type: "decimal" | "digit" | "numeric";
    
    /**
     * The character that this numeric value is associated with.
     * Example: 'A'
     */
    character: string;
}

export const DERIVED_NUMERIC_TYPE_FIELDS = [
    "numeric_value",
    "numeric_type",
    "character"
];
//#endregion

//#region data-files/v6.3.0/extracted/DerivedNumericValues.txt
/**
 * Interface representing the derived numeric values from the Unicode Character Database.
 */
export interface DerivedNumericValues {
    /**
     * The numeric value associated with a character.
     * Example: "1.0"
     */
    numeric_value: string;
    
    /**
     * The numeric type of the value.
     * Example: "integer" or "decimal"
     */
    numeric_type: "integer" | "decimal";
    
    /**
     * The character associated with the numeric value.
     * Example: "A"
     */
    character: string;
}

export const DERIVED_NUMERIC_VALUES_FIELDS = [
    "numeric_value",
    "numeric_type",
    "character"
];
//#endregion

//#region data-files/v6.3.0/auxiliary/GraphemeBreakProperty.txt
/**
 * Interface representing the GraphemeBreakProperty data from Unicode Character Database.
 */
export interface GraphemeBreakProperty {
    /**
     * The Unicode character.
     * Example: 'a'
     */
    character: string;
    
    /**
     * The grapheme break property of the character.
     * Example: 'CR' (Carriage Return)
     */
    property: "CR" | "LF" | "Control" | "Extend" | "SpacingMark" | "L" | "V" | "T" | "LV" | "LVT";
}

export const GRAPHEME_BREAK_PROPERTY_FIELDS = [
    "character",
    "property"
];
//#endregion

//#region data-files/v6.3.0/auxiliary/GraphemeBreakTest.txt
/**
 * GraphemeBreakTest interface representing the default grapheme break test data.
 */
export interface GraphemeBreakTest {
    /**
     * A string containing hex Unicode code points.
     * Example: "0041 0042 0043"
     */
    code_points: string;

    /**
     * An optional comment associated with the code points.
     * Example: "# This is a comment"
     */
    comment?: string;
}

export const GRAPHEME_BREAK_TEST_FIELDS = [
    "code_points",
    "comment"
];
//#endregion

//#region data-files/v6.3.0/auxiliary/LineBreakTest.txt
/**
 * Default Line Break Test
 *
 * This interface represents the default line break test as defined in the Unicode Character Database.
 */
export interface LineBreakTest {
    /**
     * A string containing hex Unicode code points.
     * Example: "U+0041 U+0042"
     */
    unicode_string: string;

    /**
     * An optional comment associated with the Unicode string.
     * Example: "# This is a comment"
     */
    comment?: string;
}

export const LINE_BREAK_TEST_FIELDS = [
    "unicode_string",
    "comment"
];
//#endregion

//#region data-files/v6.3.0/auxiliary/SentenceBreakProperty.txt
/**
 * Interface representing the properties of SentenceBreak.
 */
export interface SentenceBreakProperty {
    /**
     * Represents the character category for sentence breaking.
     * Example: "UppercaseLetter"
     */
    character_category: "UppercaseLetter" | "LowercaseLetter" | "SentenceTerminator";

    /**
     * Indicates whether the character is a break opportunity.
     * Example: true
     */
    is_break_opportunity: boolean;

    /**
     * Specifies the language of the sentence break property.
     * Example: "en"
     */
    language: string;

    /**
     * The Unicode code point of the character.
     * Example: 65 for 'A'
     */
    code_point: number;
}

export const SENTENCE_BREAK_PROPERTY_FIELDS = [
    "character_category",
    "is_break_opportunity",
    "language",
    "code_point"
];
//#endregion

//#region data-files/v6.3.0/auxiliary/SentenceBreakTest.txt
/**
 * Default Sentence Break Test
 *
 * Format:
 * <string> (# <comment>)? 
 * <string> contains hex Unicode code points, with
 */
export interface SentenceBreakTest {
  /**
   * The string containing hex Unicode code points.
   * Example: "0041 0042 0043"
   */
  string: string;
  /**
   * An optional comment associated with the string.
   * Example: "This is a comment"
   */
  comment?: string;
}

export const SENTENCE_BREAK_TEST_FIELDS = [
  "string",
  "comment"
];
//#endregion

//#region data-files/v6.3.0/auxiliary/WordBreakProperty.txt
/**
 * Interface representing the properties defined in the WordBreakProperty Unicode Character Database.
 */
export interface WordBreakProperty {
    /**
     * The Unicode character property value for word breaking.
     * Example: "AL" for alphabetic characters.
     */
    word_break: "AL" | "CR" | "EB" | "EM" | "EX" | "FO" | "LE" | "LF" | "NS" | "NU" | "OP" | "SG" | "SP" | "SY" | "WH";

    /**
     * The Unicode character property value for word break rules.
     * Example: "XX" for unknown characters.
     */
    word_break_rules: "XX" | "ZW";
}

export const WORD_BREAK_PROPERTY_FIELDS = [
    "word_break",
    "word_break_rules"
];
//#endregion

//#region data-files/v6.3.0/auxiliary/WordBreakTest.txt
/**
 * Interface representing the Word Break Test data.
 */
export interface WordBreakTest {
    /**
     * A string containing hex Unicode code points.
     * Example: "0041 0042 0043"
     */
    string: string;
    /**
     * An optional comment associated with the string.
     * Example: "# This is a comment"
     */
    comment?: string;
}

export const WORD_BREAK_TEST_FIELDS = [
    "string",
    "comment"
];
//#endregion

