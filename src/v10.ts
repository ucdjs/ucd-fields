// This file is generated by ucd codegen. Do not edit this file directly.
// Unicode Version: 10

//#region data-files/v10.0.0/ArabicShaping.txt
/**
 * This interface defines the properties for ArabicShaping data, which includes information about the joining type and joining group of various characters.
 */
export interface ArabicShaping {
    /**
     * The code point of a character in 4-digit hexadecimal form.
     * Example: '0629'
     */
    code_point: string;

    /**
     * A short schematic name for the character, descriptive of its shape.
     * Example: 'TEH MARBUTA'
     */
    schematic_name: string;

    /**
     * The joining type of the character, which can be one of the following:
     * - "R" for Right_Joining
     * - "L" for Left_Joining
     * - "D" for Dual_Joining
     * - "C" for Join_Causing
     * - "U" for Non_Joining
     * - "T" for Transparent
     * Example: 'R'
     */
    joining_type: "R" | "L" | "D" | "C" | "U" | "T";

    /**
     * The joining group of the character, based on its schematic name.
     * Example: 'TEH_MARBUTA'
     */
    joining_group: string;
}

export const ARABIC_SHAPING_FIELDS = [
    "code_point",
    "schematic_name",
    "joining_type",
    "joining_group"
];
//#endregion

//#region data-files/v10.0.0/BidiBrackets.txt
/**
 * BidiBrackets interface represents the mapping of Unicode characters that are treated as bracket pairs by the Unicode Bidirectional Algorithm.
 */
export interface BidiBrackets {
    /**
     * Unicode code point value, represented as a hexadecimal value.
     * Example: "U+298D"
     */
    unicode_code_point: string;

    /**
     * Bidi_Paired_Bracket property value, a code point value or <none>.
     * Example: "U+298D" or "<none>"
     */
    bidi_paired_bracket: string;

    /**
     * Bidi_Paired_Bracket_Type property value, one of the following: "o" for Open, "c" for Close, or "n" for None.
     * Example: "o" for Open, "c" for Close, "n" for None
     */
    bidi_paired_bracket_type: "o" | "c" | "n";
}

export const BIDI_BRACKETS_FIELDS = [
    "unicode_code_point",
    "bidi_paired_bracket",
    "bidi_paired_bracket_type"
];
//#endregion

//#region data-files/v10.0.0/BidiCharacterTest.txt
/**
 * BidiCharacterTest interface represents a conformance test for implementations of the Unicode Bidirectional Algorithm.
 *
 * Each test case consists of a single line of text with the following fields:
 *
 * - `code_points`: A sequence of hexadecimal code point values separated by space.
 *   Example: "0041 0052 0061"
 * - `paragraph_direction`: A value representing the paragraph direction, where:
 *   - 0 represents left-to-right
 *   - 1 represents right-to-left
 *   - 2 represents auto-LTR according to rules P2 and P3 of the algorithm.
 *   Example: 0
 * - `embedding_level`: The resolved paragraph embedding level.
 *   Example: 0
 * - `resolved_levels`: A list of resolved levels; characters removed in rule X9 are indicated with an 'x'.
 *   Example: "0 1 x 2"
 * - `visual_ordering_indices`: A list of indices showing the resulting visual ordering from left to right; characters with a resolved level of 'x' are skipped.
 *   Example: "0 1 3"
 */
export interface BidiCharacterTest {
  code_points: string;
  paragraph_direction: "0" | "1" | "2";
  embedding_level: number;
  resolved_levels: string;
  visual_ordering_indices: string;
}

export const BIDI_CHARACTER_TEST_FIELDS = [
  "code_points",
  "paragraph_direction",
  "embedding_level",
  "resolved_levels",
  "visual_ordering_indices"
];
//#endregion

//#region data-files/v10.0.0/BidiMirroring.txt
/**
 * This interface represents the Bidi_Mirroring_Glyph property mappings in the Unicode Character Database.
 */
export interface BidiMirroring {
    /**
     * The code point of the original character represented as a variable-length hexadecimal value.
     * Example: '0041' for 'A'
     */
    original_code_point: string;

    /**
     * The code point of the mirrored character represented as a variable-length hexadecimal value.
     * Example: '0061' for 'a'
     */
    mirrored_code_point: string;

    /**
     * A comment indicating the mirroring fit, if applicable.
     * Example: 'BEST FIT' for characters that have a suitable mirror image.
     */
    comment?: string;
}

export const BIDI_MIRRORING_FIELDS = [
    "original_code_point",
    "mirrored_code_point",
    "comment"
];
//#endregion

//#region data-files/v10.0.0/BidiTest.txt
/**
 * This interface represents the structure of the BidiTest data.
 * It includes properties for levels, reordering, and data lines.
 */
export interface BidiTest {
    /**
     * An ordered space-delimited list of numbers indicating the resulting levels
     * for each input property value. The UBA does not assign levels to certain values;
     * those are indicated with an 'x'.
     * 
     * Example:
     *   @Levels:    1 0
     *   @Levels:    x 1 x 2
     */
    levels: string;

    /**
     * An ordered space-delimited list of numbers indicating the resulting
     * visual ordering from left to right. The numbers are zero-based, and
     * are indexes into the input string. Items with a level of 'x' are skipped.
     * 
     * Example:
     *   @Reorder:    1 0
     *   @Reorder:    3 1
     */
    reorder: string;

    /**
     * An ordered list of BIDI property values followed by a hex bitset for
     * paragraph levels (P): 1 = auto-LTR, 2 = LTR, 4 = RTL.
     * Auto-LTR (standard BIDI) uses the first L/R/AL character, and is LTR if none is found.
     * 
     * Example:
     *    L LRE R R; 7
     *    L LRE R AL; 7
     */
    data: string;
}

export const BIDI_TEST_FIELDS = ["levels", "reorder", "data"];
//#endregion

//#region data-files/v10.0.0/Blocks.txt
/**
 * Interface representing the Unicode Character Database blocks.
 */
export interface Blocks {
    /**
     * The starting code point of the block.
     * Format: U+XXXX (e.g., U+0041)
     */
    start_code: string;

    /**
     * The ending code point of the block.
     * Format: U+XXXX (e.g., U+007A)
     */
    end_code: string;

    /**
     * The name of the block.
     * Example: "Basic Latin"
     */
    block_name: string;
}

export const BLOCKS_FIELDS = [
    "start_code",
    "end_code",
    "block_name"
];
//#endregion

//#region data-files/v10.0.0/CJKRadicals.txt
/**
 * Interface representing the mapping from CJK radical numbers to characters.
 */
export interface CJKRadicals {
    /**
     * The CJK radical number, which matches the regular expression [1-9][0-9]{0,2}'?.
     * Example: "1", "2'"
     */
    cjk_radical_number: string;

    /**
     * The CJK radical character corresponding to the radical number.
     * Example: "亻"
     */
    cjk_radical_character: string;

    /**
     * The CJK unified ideograph formed from the radical only.
     * Example: "人"
     */
    cjk_unified_ideograph: string;
}

export const CJK_RADICALS_FIELDS = [
    "cjk_radical_number",
    "cjk_radical_character",
    "cjk_unified_ideograph"
];
//#endregion

//#region data-files/v10.0.0/CaseFolding.txt
/**
 * This interface represents the case folding properties as defined in the Unicode Character Database.
 */
export interface CaseFolding {
    /**
     * The Unicode code point of the character.
     * Format: Hexadecimal (e.g., U+0041 for 'A').
     */
    code: string;

    /**
     * The status of the case folding mapping.
     * Possible values: "C" (common), "F" (full), "S" (simple), "T" (Turkic special case).
     */
    status: "C" | "F" | "S" | "T";

    /**
     * The mapping for the case folding.
     * Can be a single character or multiple characters separated by spaces.
     * Example: "a" for simple case folding, "a b" for full case folding.
     */
    mapping: string;

    /**
     * The name of the character.
     * This is a descriptive name for the character represented by the code point.
     */
    name: string;
}

export const CASE_FOLDING_FIELDS = [
    "code",
    "status",
    "mapping",
    "name"
];
//#endregion

//#region data-files/v10.0.0/CompositionExclusions.txt
/**
 * This interface represents the Composition Exclusions defined in UAX #15, Unicode Normalization Forms.
 */
export interface CompositionExclusions {
    /**
     * The date when the data was last updated.
     * Format: YYYY-MM-DD
     * Example: "2017-02-15"
     */
    date: string;

    /**
     * The copyright information for the data.
     * Example: "© 2017 Unicode®, Inc."
     */
    copyright: string;

    /**
     * The URL for the terms of use.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use_url: string;

    /**
     * The URL for the Unicode Character Database documentation.
     * Example: "http://www.unicode.org/reports/tr44/"
     */
    unicode_character_database_url: string;

    /**
     * A description of the file's purpose.
     */
    description: string;

    /**
     * The URL for more information on the composition exclusions.
     * Example: "http://www.unicode.org/unicode/reports/tr15/#Primary_Exclusion_List_Table"
     */
    composition_exclusions_info_url: string;

    /**
     * The URL for the derived property Full_Composition_Exclusion.
     * Example: "DerivedNormalizationProps.txt"
     */
    full_composition_exclusion_url: string;
}

export const COMPOSITION_EXCLUSIONS_FIELDS = [
    "date",
    "copyright",
    "terms_of_use_url",
    "unicode_character_database_url",
    "description",
    "composition_exclusions_info_url",
    "full_composition_exclusion_url"
];
//#endregion

//#region data-files/v10.0.0/DerivedAge.txt
/**
 * This interface represents the derived property data from the Unicode Character Database.
 */
export interface DerivedAge {
    /**
     * The Unicode code point assigned to a character, format, control, or private-use.
     * Example: U+0041 for 'A'
     */
    code_point: string;
    /**
     * The version of Unicode in which the code point was first assigned.
     * Example: "1.1"
     */
    version: string;
    /**
     * Indicates the type of the code point assigned.
     * Example: "graphic", "format", "control", "private-use", "surrogate", "noncharacter"
     */
    type: "graphic" | "format" | "control" | "private-use" | "surrogate" | "noncharacter";
}

export const DERIVED_AGE_FIELDS = [
    "code_point",
    "version",
    "type"
];
//#endregion

//#region data-files/v10.0.0/DerivedCoreProperties.txt
/**
 * Interface representing the properties defined in the DerivedCoreProperties Unicode Character Database.
 */
export interface DerivedCoreProperties {
    /**
     * The Unicode version of the data.
     * Example: "10.0.0"
     */
    unicode_version: string;
    
    /**
     * The date when the data was last updated.
     * Format: YYYY-MM-DD, HH:MM:SS GMT
     * Example: "2017-03-19, 00:05:15 GMT"
     */
    date: string;
    
    /**
     * The copyright information for the data.
     * Example: "© 2017 Unicode®, Inc."
     */
    copyright: string;
    
    /**
     * The URL for the terms of use.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;
    
    /**
     * The URL for the documentation of the Unicode Character Database.
     * Example: "http://www.unicode.org/reports/tr44/"
     */
    documentation_url: string;
}

export const DERIVED_CORE_PROPERTIES_FIELDS = [
    "unicode_version",
    "date",
    "copyright",
    "terms_of_use",
    "documentation_url"
];
//#endregion

//#region data-files/v10.0.0/DerivedNormalizationProps.txt
/**
 * Interface representing the properties of DerivedNormalizationProps.
 */
export interface DerivedNormalizationProps {
    /**
     * The normalization form, which can be one of the following: "NFC", "NFD", "NFKC", "NFKD".
     * Example: "NFC"
     */
    normalization_form: "NFC" | "NFD" | "NFKC" | "NFKD";

    /**
     * A boolean indicating whether to use compatibility normalization.
     * Example: true
     */
    compatibility: boolean;

    /**
     * The version of the normalization algorithm used.
     * Example: "1.0"
     */
    version: string;

    /**
     * An optional description of the normalization process.
     * Example: "This normalization process is used for..."
     */
    description?: string;
}

export const DERIVED_NORMALIZATION_PROPS_FIELDS = [
    "normalization_form",
    "compatibility",
    "version",
    "description"
];
//#endregion

//#region data-files/v10.0.0/EastAsianWidth.txt
/**
 * East_Asian_Width Property
 *
 * This interface represents the East Asian Width property as defined in the Unicode Character Database.
 *
 * The format consists of two fields:
 * - `code_point`: A Unicode code point value or range of code point values (e.g., U+3400..U+4DBF).
 * - `east_asian_width`: The East Asian Width property, which can be one of the following values:
 *   - "A": Ambiguous
 *   - "F": Full-width
 *   - "H": Half-width
 *   - "N": Neutral
 *   - "Na": Narrow
 *   - "W": Wide
 *
 * All code points not explicitly listed are given the value "N". Unassigned code points in specific blocks default to "W".
 *
 * For more information, see UAX #11: East Asian Width at http://www.unicode.org/reports/tr11/
 */
export interface EastAsianWidth {
    code_point: string;
    east_asian_width: "A" | "F" | "H" | "N" | "Na" | "W";
}

export const EAST_ASIAN_WIDTH_FIELDS = [
    "code_point",
    "east_asian_width"
];
//#endregion

//#region data-files/v10.0.0/EmojiSources.txt
/**
 * Interface representing the mappings between Unicode code points and Shift-JIS codes for cell phone carrier symbols.
 */
export interface EmojiSources {
  /**
   * Unicode code point or sequence.
   * Example: "U+1F600"
   */
  unicode_code_point_or_sequence: string;
  /**
   * DoCoMo Shift-JIS code.
   * Example: "0xE63A"
   */
  docomo_shift_jis_code: string;
  /**
   * KDDI Shift-JIS code.
   * Example: "0xE63B"
   */
  kddi_shift_jis_code: string;
  /**
   * SoftBank Shift-JIS code.
   * Example: "0xE63C"
   */
  softbank_shift_jis_code: string;
}

export const EMOJI_SOURCES_FIELDS = [
  "unicode_code_point_or_sequence",
  "docomo_shift_jis_code",
  "kddi_shift_jis_code",
  "softbank_shift_jis_code"
];
//#endregion

//#region data-files/v10.0.0/HangulSyllableType.txt
/**
 * Interface representing the Hangul Syllable Type data.
 */
export interface HangulSyllableType {
    /**
     * The Hangul syllable type code.
     * Format: "HANGUL_SYLLABLE_TYPE_CODE"
     * Example: "L"
     */
    hangul_syllable_type_code: "L" | "V" | "LV" | "LVT";

    /**
     * The description of the syllable type.
     * Format: "DESCRIPTION"
     * Example: "Consonant"
     */
    description: string;
}

export const HANGUL_SYLLABLE_TYPE_FIELDS = [
    "hangul_syllable_type_code",
    "description"
];
//#endregion

//#region data-files/v10.0.0/IndicPositionalCategory.txt
/**
 * This interface defines the Indic Positional Category property aimed at specifying syllabic structure for Indic scripts.
 * 
 * The property is used to categorize characters based on their positional attributes in relation to consonants and other characters in Indic scripts.
 * 
 * The following scripts are assessed for this property: Ahom, Balinese, Batak, Bengali, Bhaiksuki, Brahmi, Buginese, Buhid, Chakma, Cham, Devanagari, Grantha, 
 * Gujarati, Gurmukhi, Hanunoo, Javanese, Kaithi, Kannada, Kharoshthi, Khmer, Khojki, Khudawadi, Lao, Lepcha, Limbu, Malayalam, Marchen, 
 * Masaram Gondi, Meetei Mayek, Modi, Myanmar, Newa, New Tai Lue, Oriya, Rejang, Saurashtra, Sharada, Siddham, Sinhala, Soyombo, Sundanese, 
 * Syloti Nagri, Tagalog, Tagbanwa, Tai Tham, Tai Viet, Takri, Tamil, Telugu, Thai, Tibetan, Tirhuta, and Zanabazar Square.
 * 
 * All characters for scripts not in this list take the default value for this property.
 * 
 * Example of format:
 * - Field 0: Unicode code point value or range (e.g., U+0BC1)
 * - Field 1: Indic_Positional_Category property value (e.g., "Top")
 * 
 * Note: Some characters may have contextually variable placement.
 */
export interface IndicPositionalCategory {
    unicode_code_point: string;
    indic_positional_category: "Top" | "Bottom" | "Left" | "Right" | "None";
}

export const INDIC_POSITIONAL_CATEGORY_FIELDS = [
    "unicode_code_point",
    "indic_positional_category"
];
//#endregion

//#region data-files/v10.0.0/IndicSyllabicCategory.txt
/**
 * This interface defines the Indic Syllabic Category property, which is aimed at analyzing and processing Indic scripts.
 *
 * The property specifies the syllabic structure and segmentation rules for Indic scripts, which include:
 * - Ahom
 * - Balinese
 * - Batak
 * - Bengali
 * - Bhaiksuki
 * - Brahmi
 * - Buginese
 * - Buhid
 * - Chakma
 * - Cham
 * - Devanagari
 * - Grantha
 * - Gujarati
 * - Gurmukhi
 * - Hanunoo
 * - Javanese
 * - Kaithi
 * - Kannada
 * - Kayah Li
 * - Kharoshthi
 * - Khmer
 * - Khojki
 * - Khudawadi
 * - Lao
 * - Lepcha
 * - Limbu
 * - Mahajani
 * - Malayalam
 * - Marchen
 * - Masaram Gondi
 * - Meetei Mayek
 * - Modi
 * - Multani
 * - Myanmar
 * - Newa
 * - New Tai Lue
 * - Oriya
 * - Phags-pa
 * - Rejang
 * - Saurashtra
 * - Sharada
 * - Siddham
 * - Sinhala
 * - Soyombo
 * - Sundanese
 * - Syloti Nagri
 * - Tagalog
 * - Tagbanwa
 * - Tai Le
 * - Tai Tham
 * - Tai Viet
 * - Takri
 * - Tamil
 * - Telugu
 * - Thai
 * - Tibetan
 * - Tirhuta
 * - Zanabazar Square
 *
 * All characters for scripts not listed take the default value for this property unless individually listed.
 */
export interface IndicSyllabicCategory {
    /**
     * Unicode code point value or range of code point values.
     * Example: U+0900 or U+0900-U+0903
     */
    unicode_code_point: string;
    /**
     * Indic Syllabic Category property value.
     * Example: "Vowel", "Consonant"
     */
    indic_syllabic_category: "Vowel" | "Consonant" | "Other";
    /**
     * General Category property value, Unicode character name, and code point count.
     * Example: "Lu # LATIN CAPITAL LETTER A [1]"
     */
    comment: string;
}

export const INDIC_SYLLABIC_CATEGORY_FIELDS = [
    "unicode_code_point",
    "indic_syllabic_category",
    "comment"
];
//#endregion

//#region data-files/v10.0.0/Jamo.txt
/**
 * This interface defines the Jamo_Short_Name property.
 *
 * Each entry represents a conjoining jamo character that participates in the algorithmic determination of Hangul syllable character names.
 *
 * @property {"string"} code_point - The code point of a conjoining jamo character in 4-digit hexadecimal form (e.g., "1100").
 * @property {"string"} jamo_short_name - The Jamo_Short_Name as a one-, two-, or three-character ASCII string (e.g., "G", "GG", "N").
 */
export interface Jamo {
    "code_point": string;
    "jamo_short_name": string;
}

export const JAMO_FIELDS = ["code_point", "jamo_short_name"];
//#endregion

//#region data-files/v10.0.0/LineBreak.txt
/**
 * This interface represents the Line Break property data in the Unicode Character Database.
 */
export interface LineBreak {
    /**
     * Unicode code point value or range of code point values.
     * Example: U+0041 or U+0041..U+005A
     */
    code_point: string;
    /**
     * Line Break property, which can be one of the following:
     * - Non-tailorable: "BK", "CM", "CR", "GL", "LF", "NL", "SP", "WJ", "ZW", "ZWJ"
     * - Tailorable: "AI", "AL", "B2", "BA", "BB", "CB", "CJ", "CL", "CP", "EB",
     *   "EM", "EX", "H2", "H3", "HL", "HY", "ID", "IN", "IS", "JL",
     *   "JT", "JV", "NS", "NU", "OP", "PO", "PR", "QU", "RI", "SA",
     *   "SG", "SY", "XX"
     * Example: "BK"
     */
    line_break_property: "BK" | "CM" | "CR" | "GL" | "LF" | "NL" | "SP" | "WJ" | "ZW" | "ZWJ" | "AI" | "AL" | "B2" | "BA" | "BB" | "CB" | "CJ" | "CL" | "CP" | "EB" | "EM" | "EX" | "H2" | "H3" | "HL" | "HY" | "ID" | "IN" | "IS" | "JL" | "JT" | "JV" | "NS" | "NU" | "OP" | "PO" | "PR" | "QU" | "RI" | "SA" | "SG" | "SY" | "XX";
}

export const LINE_BREAK_FIELDS = ["code_point", "line_break_property"] as const;
//#endregion

//#region data-files/v10.0.0/NameAliases.txt
/**
 * This interface defines the formal name aliases for Unicode characters.
 */
export interface NameAliases {
  /**
   * The code point of the Unicode character, represented as a hexadecimal string.
   * Example: "U+0041" for the character 'A'.
   */
  code_point: string;

  /**
   * The alias for the Unicode character, which can be a formal name or an abbreviation.
   * Example: "LATIN CAPITAL LETTER A" or "C1".
   */
  alias: string;

  /**
   * The type of the alias, which can be one of the following: "correction", "control", "alternate", "figment", "abbreviation".
   * Comparisons of type labels should ignore case.
   */
  type: "correction" | "control" | "alternate" | "figment" | "abbreviation";
}

export const NAME_ALIASES_FIELDS = [
  "code_point",
  "alias",
  "type"
];
//#endregion

//#region data-files/v10.0.0/NamedSequences.txt
/**
 * Unicode Named Character Sequences
 *
 * This interface represents the named character sequences as defined in the Unicode Character Database.
 */
export interface NamedSequences {
  /**
   * The name of the sequence.
   * Example: "EXAMPLE NAME"
   */
  name: string;

  /**
   * The code point sequence for the USI, represented as a string of space-separated code points.
   * Example: "1000 1001 1002"
   */
  code_point_sequence: string;
}

export const NAMED_SEQUENCES_FIELDS = ["name", "code_point_sequence"];
//#endregion

//#region data-files/v10.0.0/NamedSequencesProv.txt
/**
 * Provisional Unicode Named Character Sequences
 *
 * This interface represents the provisional named character sequences as defined in the Unicode Character Database.
 */
export interface NamedSequencesProv {
    /**
     * The name of the sequence.
     * Example: "EXAMPLE NAME"
     */
    name: string;

    /**
     * The code point sequence for USI, represented as a string of space-separated code points.
     * Example: "1000 1001 1002"
     */
    code_point_sequence: string;
}

export const NAMED_SEQUENCES_PROV_FIELDS = [
    "name",
    "code_point_sequence"
];
//#endregion

//#region data-files/v10.0.0/NormalizationCorrections.txt
/**
 * This interface represents the normalization corrections as defined in the Unicode Character Database.
 */
export interface NormalizationCorrections {
    /**
     * Unicode code point, represented as a hexadecimal string (e.g., "U+0041" for 'A').
     */
    unicode_code_point: string;

    /**
     * Original (erroneous) decomposition of the character.
     */
    original_decomposition: string;

    /**
     * Corrected decomposition of the character.
     */
    corrected_decomposition: string;

    /**
     * Version of Unicode for which the correction was entered into UnicodeData.txt, in n.n.n format (e.g., "9.0.0").
     */
    unicode_version: string;

    /**
     * Indicates the Unicode Corrigendum which documents the correction (e.g., "Corrigendum #3").
     */
    comment: string;
}

export const NORMALIZATION_CORRECTIONS_FIELDS = [
    "unicode_code_point",
    "original_decomposition",
    "corrected_decomposition",
    "unicode_version",
    "comment"
];
//#endregion

//#region data-files/v10.0.0/NormalizationTest.txt
/**
 * Interface representing the normalization test suite data.
 */
export interface NormalizationTest {
    /**
     * The source code points.
     * Example: "U+0041; U+00C1"
     */
    source: string;

    /**
     * The NFC normalized code points.
     * Example: "U+0041; U+00C1"
     */
    nfc: string;

    /**
     * The NFD normalized code points.
     * Example: "U+0041; U+00C1"
     */
    nfd: string;

    /**
     * The NFKC normalized code points.
     * Example: "U+0041; U+00C1"
     */
    nfkc: string;

    /**
     * The NFKD normalized code points.
     * Example: "U+0041; U+00C1"
     */
    nfkd: string;
}

export const NORMALIZATION_TEST_FIELDS = [
    "source",
    "nfc",
    "nfd",
    "nfkc",
    "nfkd"
];
//#endregion

//#region data-files/v10.0.0/NushuSources.txt
/**
 * Interface representing the Unicode Character Database.
 */
export interface NushuSources {
    /**
     * The date of the data file in GMT format.
     * Example: "2017-02-14T00:00:00Z"
     */
    date: string;
    /**
     * The copyright information for the data file.
     * Example: "© 2017 Unicode®, Inc."
     */
    copyright: string;
    /**
     * The terms of use for the data file.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;
    /**
     * The documentation link for the Unicode Character Database.
     * Example: "http://www.unicode.org/reports/tr44/"
     */
    documentation: string;
}

export const NUSHU_SOURCES_FIELDS = [
    "date",
    "copyright",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v10.0.0/PropList.txt
/**
 * Interface representing the Unicode Character Database properties.
 */
export interface PropList {
    /**
     * The date when the data was generated.
     * Format: YYYY-MM-DD, HH:MM:SS GMT
     * Example: "2017-03-10, 08:25:30 GMT"
     */
    date: string;

    /**
     * The copyright information for the Unicode data.
     * Example: "© 2017 Unicode®, Inc."
     */
    copyright: string;

    /**
     * The URL for the terms of use for the Unicode data.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;

    /**
     * The URL for the documentation of the Unicode Character Database.
     * Example: "http://www.unicode.org/reports/tr44/"
     */
    documentation_url: string;
}

export const PROP_LIST_FIELDS = [
    "date",
    "copyright",
    "terms_of_use",
    "documentation_url"
];
//#endregion

//#region data-files/v10.0.0/PropertyAliases.txt
/**
 * This interface contains aliases for properties used in the Unicode Character Database (UCD).
 * The names can be used for XML formats of UCD data, for regular-expression property tests,
 * and other programmatic textual descriptions of Unicode data.
 *
 * Each property has an abbreviated name and a long name, along with possible additional aliases.
 *
 * Note: Property value names are not unique across properties, and some property names may
 * be the same as property value names. The combination of property value and property name
 * is unique.
 */
export interface PropertyAliases {
  /**
   * Abbreviated name for the property.
   */
  abbreviated_name: string;

  /**
   * Long name for the property.
   */
  long_name: string;

  /**
   * Additional aliases for the property, if any.
   */
  additional_aliases?: string[];
}

export const PROPERTY_ALIASES_FIELDS = [
  "abbreviated_name",
  "long_name",
  "additional_aliases"
];
//#endregion

//#region data-files/v10.0.0/PropertyValueAliases.txt
/**
 * This interface represents the property value aliases used in the Unicode Character Database.
 * Each property value name is associated with a specific property and may have multiple aliases.
 *
 * The properties include:
 * - property: The property for which the value name is used (e.g., Bidi_Class).
 * - abbreviated_name: A short form of the property value name (e.g., AL).
 * - long_name: A detailed description of the property value name (e.g., Arabic Letter).
 *
 * Note: Property value names are not unique across properties, and some property names may be the same as property value names.
 */
export interface PropertyValueAliases {
  property: string;
  abbreviated_name: string;
  long_name: string;
}

export const PROPERTY_VALUE_ALIASES_FIELDS = [
  "property",
  "abbreviated_name",
  "long_name"
];
//#endregion

//#region data-files/v10.0.0/ScriptExtensions.txt
/**
 * The ScriptExtensions interface represents the Unicode Script Extensions property,
 * which indicates which characters are commonly used with more than one script.
 */
export interface ScriptExtensions {
    /**
     * A set of one or more abbreviated Script property values.
     * The ordering of the values in that set is not material, but for stability in presentation
     * it is given here as alphabetical.
     * 
     * Example: "Latin, Greek"
     */
    script_extensions: "string";
    /**
     * A list of code points associated with the Script_Extensions value,
     * listed in code point order.
     * 
     * Example: "U+0041, U+0042"
     */
    code_points: "string";
}

export const SCRIPT_EXTENSIONS_FIELDS = [
    "script_extensions",
    "code_points"
];
//#endregion

//#region data-files/v10.0.0/Scripts.txt
/**
 * Interface representing the Unicode Character Database Scripts.
 */
export interface Scripts {
    /**
     * The name of the script.
     * Example: "Latin"
     */
    script_name: string;

    /**
     * The range of Unicode code points for the script.
     * Example: "U+0000-U+007F"
     */
    code_point_range: string;

    /**
     * The ISO 15924 code for the script.
     * Example: "Latn"
     */
    iso_15924: string;

    /**
     * A description of the script.
     * Example: "Latin script used for many languages"
     */
    description: string;

    /**
     * The direction of the script (e.g., left-to-right or right-to-left).
     * Example: "LTR"
     */
    direction: "LTR" | "RTL";
}

export const SCRIPTS_FIELDS = [
    "script_name",
    "code_point_range",
    "iso_15924",
    "description",
    "direction"
];
//#endregion

//#region data-files/v10.0.0/SpecialCasing.txt
/**
 * This interface represents the special casing mappings for Unicode characters.
 */
export interface SpecialCasing {
    /**
     * The Unicode code point of the character, expressed in hexadecimal format.
     * Example: '0041' for 'A'
     */
    code: string;

    /**
     * The lowercase mapping of the character, expressed as character values in hex.
     * If there are multiple characters, they are separated by spaces.
     * Example: '0061' for 'a'
     */
    lower: string;

    /**
     * The titlecase mapping of the character, expressed as character values in hex.
     * If there are multiple characters, they are separated by spaces.
     * Example: '0041 0062' for 'Ab'
     */
    title: string;

    /**
     * The uppercase mapping of the character, expressed as character values in hex.
     * If there are multiple characters, they are separated by spaces.
     * Example: '0041' for 'A'
     */
    upper: string;

    /**
     * An optional list of conditions that override the normal behavior of casing.
     * This can include language IDs or casing contexts, separated by spaces.
     * Example: 'en US' or 'Not_en'
     */
    condition_list?: string;

    /**
     * A comment providing additional information about the mapping.
     * Example: 'Latin Capital Letter A'
     */
    comment?: string;
}

export const SPECIAL_CASING_FIELDS = [
    "code",
    "lower",
    "title",
    "upper",
    "condition_list",
    "comment"
];
//#endregion

//#region data-files/v10.0.0/StandardizedVariants.txt
/**
 * Interface representing standardized variation sequences defined in the Unicode Standard.
 */
export interface StandardizedVariants {
  /**
   * The variation sequence.
   * Example: "U+E0100 U+E0101"
   */
  variation_sequence: string;
  
  /**
   * The description of the desired appearance.
   * Example: "This character appears as a bold version."
   */
  description: string;
  
  /**
   * Indicates where the appearance is only different in particular shaping environments.
   * Example: "This shape is used in cursive writing."
   */
  shaping_environments: string;
}

export const STANDARDIZED_VARIANTS_FIELDS = [
  "variation_sequence",
  "description",
  "shaping_environments"
];
//#endregion

//#region data-files/v10.0.0/TangutSources.txt
/**
 * This interface represents the data structure for TangutSources.
 */
export interface TangutSources {
    /**
     * The date of the file creation in GMT format.
     * Example: "2017-04-13T01:00:00Z"
     */
    date: string;
    /**
     * The copyright information for the file.
     * Example: "© 2017 Unicode®, Inc."
     */
    copyright: string;
    /**
     * The URL for the terms of use.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use_url: string;
    /**
     * The URL for the documentation of the Unicode Character Database.
     * Example: "http://www.unicode.org/reports/tr44/"
     */
    documentation_url: string;
    /**
     * Indicates if the file is normative.
     * Example: true
     */
    is_normative: boolean;
}

export const TANGUT_SOURCES_FIELDS = [
    "date",
    "copyright",
    "terms_of_use_url",
    "documentation_url",
    "is_normative"
];
//#endregion

//#region data-files/v10.0.0/USourceData.txt
/**
 * Interface representing the U-source data for ideographs.
 */
export interface USourceData {
    /**
     * The U-source ID.
     * Format: UTC-XXXXX or UCI-XXXXX
     * Example: UTC-00001
     */
    u_source_id: string;

    /**
     * Text indicating the ideograph's status.
     * Possible values: "C", "D", "E", "F", "G", "N", "U", "UNC-2013", "UNC-2015", "UK-2015", "V", "W", "X"
     * Example: "E"
     */
    status: "C" | "D" | "E" | "F" | "G" | "N" | "U" | "UNC-2013" | "UNC-2015" | "UK-2015" | "V" | "W" | "X";

    /**
     * A Unicode code point.
     * Format: U+XXXXXX
     * Example: U+2B88A
     */
    unicode_code_point: string;

    /**
     * Radical-stroke count.
     * Example: 4.2
     */
    radical_stroke_count: number;

    /**
     * Virtual KangXi dictionary position.
     * Example: 0082.031
     */
    kangxi_position: string;

    /**
     * Ideographic Description Sequence (IDS), if possible.
     * Example: "⿱乳年"
     */
    ideographic_description_sequence?: string;

    /**
     * Source(s) of the ideograph.
     * Example: "kCowles 4762"
     */
    sources: string;
}

export const USOURCE_DATA_FIELDS = [
    "u_source_id",
    "status",
    "unicode_code_point",
    "radical_stroke_count",
    "kangxi_position",
    "ideographic_description_sequence",
    "sources"
];
//#endregion

//#region data-files/v10.0.0/VerticalOrientation.txt
/**
 * Vertical_Orientation property interface.
 */
export interface VerticalOrientation {
    /**
     * Unicode code point value or range of code point values in hexadecimal form.
     * Example: U+0041 for 'A' or U+0030..U+0039 for '0' to '9'.
     */
    code_point: string;

    /**
     * Vertical_Orientation property value, one of the following:
     * - "U" - Upright, the same orientation as in the code charts.
     * - "R" - Rotated 90 degrees clockwise compared to the code charts.
     * - "Tu" - Transformed typographically, with fallback to Upright.
     * - "Tr" - Transformed typographically, with fallback to Rotated.
     */
    vertical_orientation: "U" | "R" | "Tu" | "Tr";
}

export const VERTICAL_ORIENTATION_FIELDS = [
    "code_point",
    "vertical_orientation"
];
//#endregion

//#region data-files/v10.0.0/extracted/DerivedBidiClass.txt
/**
 * Interface representing the DerivedBidiClass.
 */
export interface DerivedBidiClass {
    /**
     * The date of the document in ISO 8601 format.
     * Example: "2017-03-08T08:41:46Z"
     */
    date: string;
    /**
     * The copyright information for the document.
     * Example: "© 2017 Unicode®, Inc."
     */
    copyright: string;
    /**
     * The URL for the terms of use.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use_url: string;
    /**
     * The documentation URL for the Unicode Character Database.
     * Example: "http://www.unicode.org/reports/tr44/"
     */
    unicode_character_database_url: string;
}

export const DERIVED_BIDI_CLASS_FIELDS = [
    "date",
    "copyright",
    "terms_of_use_url",
    "unicode_character_database_url"
];
//#endregion

//#region data-files/v10.0.0/extracted/DerivedBinaryProperties.txt
/**
 * Interface representing the derived binary properties from the Unicode Character Database.
 */
export interface DerivedBinaryProperties {
    /**
     * Indicates whether the character is a control character.
     * Example: "true" or "false"
     */
    control: "true" | "false";

    /**
     * Indicates whether the character is a surrogate.
     * Example: "true" or "false"
     */
    surrogate: "true" | "false";

    /**
     * Indicates whether the character is a private use character.
     * Example: "true" or "false"
     */
    private_use: "true" | "false";

    /**
     * Indicates whether the character is a non-character.
     * Example: "true" or "false"
     */
    non_character: "true" | "false";

    /**
     * Indicates whether the character is a whitespace character.
     * Example: "true" or "false"
     */
    whitespace: "true" | "false";
}

export const DERIVED_BINARY_PROPERTIES_FIELDS = [
    "control",
    "surrogate",
    "private_use",
    "non_character",
    "whitespace"
];
//#endregion

//#region data-files/v10.0.0/extracted/DerivedCombiningClass.txt
/**
 * Interface representing the DerivedCombiningClass.
 */
export interface DerivedCombiningClass {
    /**
     * The Unicode code point of the character.
     * Example: 0x0300
     */
    code_point: number;
    
    /**
     * The canonical combining class of the character.
     * Example: 230
     */
    canonical_combining_class: number;
    
    /**
     * The character itself as a string.
     * Example: "̀"
     */
    character: string;
}

export const DERIVED_COMBINING_CLASS_FIELDS = [
    "code_point",
    "canonical_combining_class",
    "character"
];
//#endregion

//#region data-files/v10.0.0/extracted/DerivedDecompositionType.txt
/**
 * Interface representing the DerivedDecompositionType.
 */
export interface DerivedDecompositionType {
    /**
     * The Unicode character for which the decomposition is defined.
     * Example: 'A'
     */
    character: string;

    /**
     * The decomposition mapping for the character.
     * Example: 'A' -> 'A' (no decomposition)
     * Example: 'é' -> 'e' + '´'
     */
    decomposition: string;

    /**
     * The type of decomposition.
     * Can be one of the following: "canonical", "compatibility"
     */
    type: "canonical" | "compatibility";

    /**
     * The source of the decomposition data.
     * Example: 'Unicode Character Database'
     */
    source: string;
}

export const DERIVED_DECOMPOSITION_TYPE_FIELDS = [
    "character",
    "decomposition",
    "type",
    "source"
];
//#endregion

//#region data-files/v10.0.0/extracted/DerivedEastAsianWidth.txt
/**
 * Interface representing the DerivedEastAsianWidth data.
 */
export interface DerivedEastAsianWidth {
    /**
     * The character for which the width is defined.
     * Example: 'A'
     */
    character: string;
    /**
     * The derived east asian width value for the character.
     * Example: 'Narrow', 'Wide', 'Fullwidth'
     */
    east_asian_width: "Narrow" | "Wide" | "Fullwidth" | "Halfwidth";
}

export const DERIVED_EAST_ASIAN_WIDTH_FIELDS = [
    "character",
    "east_asian_width"
];
//#endregion

//#region data-files/v10.0.0/extracted/DerivedGeneralCategory.txt
/**
 * Interface representing the derived general category data.
 */
export interface DerivedGeneralCategory {
    /**
     * The Unicode character category, e.g., "Lu" for uppercase letters.
     */
    category: "Lu" | "Ll" | "Lt" | "Lm" | "Lo" | "Mn" | "Mc" | "Me" | "Nd" | "Nl" | "No" | "Pc" | "Pd" | "Ps" | "Pe" | "Pi" | "Pf" | "Po" | "Sm" | "Sc" | "Sk" | "So" | "Zs" | "Zl" | "Zp";

    /**
     * The description of the category, e.g., "Uppercase Letter".
     */
    description: string;

    /**
     * The numeric value associated with the category, if applicable.
     * Example: 1 for "Lu".
     */
    numeric_value?: number;
}

export const DERIVED_GENERAL_CATEGORY_FIELDS = [
    "category",
    "description",
    "numeric_value"
];
//#endregion

//#region data-files/v10.0.0/extracted/DerivedJoiningGroup.txt
/**
 * Interface representing the Unicode Derived Joining Group.
 */
export interface DerivedJoiningGroup {
    /**
     * The name of the derived joining group.
     * Example: "Left"
     */
    name: string;

    /**
     * The code point range for the derived joining group.
     * Format: U+XXXX..U+YYYY
     * Example: "U+0000..U+007F"
     */
    code_point_range: string;

    /**
     * The properties associated with the derived joining group.
     * Example: "C, L"
     */
    properties: string;

    /**
     * The version of the Unicode standard that this derived joining group is associated with.
     * Example: "10.0.0"
     */
    version: string;
}

export const DERIVED_JOINING_GROUP_FIELDS = [
    "name",
    "code_point_range",
    "properties",
    "version"
];
//#endregion

//#region data-files/v10.0.0/extracted/DerivedJoiningType.txt
/**
 * Interface representing the derived joining type as defined in the Unicode Character Database.
 */
export interface DerivedJoiningType {
    /**
     * The character that represents the joining type.
     * Example: 'A'
     */
    character: string;

    /**
     * The joining type of the character.
     * Union type representing the possible joining types.
     * Example: 'L', 'R', 'D', 'C', 'T', 'U', 'A'
     */
    joining_type: "L" | "R" | "D" | "C" | "T" | "U" | "A";

    /**
     * The code point of the character in hexadecimal format.
     * Example: '0x0041' for 'A'
     */
    code_point: string;

    /**
     * The directionality of the character.
     * Union type representing the possible directionality values.
     * Example: 'LTR', 'RTL'
     */
    directionality: "LTR" | "RTL";
}

export const DERIVED_JOINING_TYPE_FIELDS = [
    "character",
    "joining_type",
    "code_point",
    "directionality"
];
//#endregion

//#region data-files/v10.0.0/extracted/DerivedLineBreak.txt
/**
 * Interface representing the DerivedLineBreak data structure.
 */
export interface DerivedLineBreak {
    /**
     * The date and time when the data was created, in GMT format.
     * Example: "2017-03-08T08:41:50Z"
     */
    created_at: string;

    /**
     * The copyright information for the data.
     * Example: "© 2017 Unicode®, Inc."
     */
    copyright: string;

    /**
     * The URL for the terms of use.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use_url: string;

    /**
     * The URL for the documentation of the Unicode Character Database.
     * Example: "http://www.unicode.org/reports/tr44/"
     */
    documentation_url: string;
}

export const DERIVED_LINE_BREAK_FIELDS = [
    "created_at",
    "copyright",
    "terms_of_use_url",
    "documentation_url"
];
//#endregion

//#region data-files/v10.0.0/extracted/DerivedName.txt
/**
 * This interface represents the derived names of Unicode characters as specified in the Unicode Character Database.
 */
export interface DerivedName {
    /**
     * The Unicode code point value or range of code point values.
     * Example: U+4E12 or U+2F89F
     */
    code_point: string;

    /**
     * The Name property value or pattern derived from the code point.
     * Values containing a '*' character are patterns that use the placeholder '*'
     * in place of the code point in hexadecimal format.
     * Example: CJK UNIFIED IDEOGRAPH-* becomes CJK UNIFIED IDEOGRAPH-4E12 for U+4E12.
     */
    name_property: string;
}

export const DERIVED_NAME_FIELDS = [
    "code_point",
    "name_property"
];
//#endregion

//#region data-files/v10.0.0/extracted/DerivedNumericType.txt
/**
 * Interface representing the DerivedNumericType from the Unicode Character Database.
 */
export interface DerivedNumericType {
    /**
     * The numeric value of the character.
     * Example: 1.0
     */
    numeric_value: number;
    
    /**
     * The numeric type of the character, which can be one of the following: "decimal", "digit", "numeric".
     * Example: "decimal"
     */
    numeric_type: "decimal" | "digit" | "numeric";
}

export const DERIVED_NUMERIC_TYPE_FIELDS = [
    "numeric_value",
    "numeric_type"
];
//#endregion

//#region data-files/v10.0.0/extracted/DerivedNumericValues.txt
/**
 * DerivedNumericValues interface represents the derived numeric values as defined in the Unicode Character Database.
 */
export interface DerivedNumericValues {
    /**
     * The numeric value of the character as a decimal number.
     * Example: "1.0"
     */
    numeric_value: string;

    /**
     * The numeric type of the character, which can be one of the following: "integer", "decimal", "fractional".
     * Example: "integer"
     */
    numeric_type: "integer" | "decimal" | "fractional";

    /**
     * The numeric value in a different base, if applicable.
     * Example: "0x1A"
     */
    numeric_value_base: string;

    /**
     * The character associated with the numeric value.
     * Example: "U+0041"
     */
    character: string;
}

export const DERIVED_NUMERIC_VALUES_FIELDS = [
    "numeric_value",
    "numeric_type",
    "numeric_value_base",
    "character"
];
//#endregion

//#region data-files/v10.0.0/auxiliary/GraphemeBreakProperty.txt
/**
 * Interface representing the Grapheme Break Property data.
 */
export interface GraphemeBreakProperty {
    /**
     * The character that represents the grapheme break property.
     * Example: "CR" for carriage return.
     */
    character: string;
    /**
     * The description of the grapheme break property.
     * Example: "Control" for control characters.
     */
    description: string;
    /**
     * The Unicode category of the character.
     * Example: "Zs" for space separator.
     */
    unicode_category: string;
}

export const GRAPHEME_BREAK_PROPERTY_FIELDS = [
    "character",
    "description",
    "unicode_category"
];
//#endregion

//#region data-files/v10.0.0/auxiliary/GraphemeBreakTest.txt
/**
 * GraphemeBreakTest
 *
 * This interface represents the default grapheme cluster break test data.
 *
 * @property {string} string - A string containing hex Unicode code points.
 * @property {string} comment - An optional comment associated with the string.
 */
export interface GraphemeBreakTest {
    string: string;
    comment?: string;
}

export const GRAPHEME_BREAK_TEST_FIELDS = [
    "string",
    "comment"
];
//#endregion

//#region data-files/v10.0.0/auxiliary/LineBreakTest.txt
/**
 * Default Line Break Test
 *
 * This interface represents the default line break test format.
 *
 * The format consists of a string that contains hex Unicode code points, optionally followed by a comment.
 *
 * Example:
 * "0041 0042 0043 (# This is a comment)"
 */
export interface LineBreakTest {
    /**
     * A string containing hex Unicode code points, with an optional comment.
     * The comment is enclosed in parentheses and starts with a hash symbol (#).
     * Example: "0041 0042 0043 (# This is a comment)"
     */
    line_break: string;
}

export const LINE_BREAK_TEST_FIELDS = ["line_break"];
//#endregion

//#region data-files/v10.0.0/auxiliary/SentenceBreakProperty.txt
/**
 * Interface representing the properties related to sentence breaking as defined in Unicode.
 */
export interface SentenceBreakProperty {
    /**
     * The date when the data was last updated.
     * Format: YYYY-MM-DD, HH:MM:SS GMT
     * Example: "2017-03-08, 08:42:08 GMT"
     */
    date: string;

    /**
     * The copyright information for the Unicode data.
     * Example: "© 2017 Unicode®, Inc."
     */
    copyright: string;

    /**
     * The URL for the terms of use for the Unicode data.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use_url: string;

    /**
     * The documentation URL for the Unicode Character Database.
     * Example: "http://www.unicode.org/reports/tr44/"
     */
    documentation_url: string;
}

export const SENTENCE_BREAK_PROPERTY_FIELDS = [
    "date",
    "copyright",
    "terms_of_use_url",
    "documentation_url"
];
//#endregion

//#region data-files/v10.0.0/auxiliary/SentenceBreakTest.txt
/**
 * Interface representing the default sentence break test data.
 */
export interface SentenceBreakTest {
    /**
     * A string containing hex Unicode code points.
     * Example: "0041 0042 0043"
     */
    code_points: string;
    /**
     * An optional comment associated with the code points.
     * Example: "# This is a comment"
     */
    comment?: string;
}

export const SENTENCE_BREAK_TEST_FIELDS = [
    "code_points",
    "comment"
];
//#endregion

//#region data-files/v10.0.0/auxiliary/WordBreakProperty.txt
/**
 * Interface representing the WordBreakProperty data.
 */
export interface WordBreakProperty {
    /**
     * The word break property value.
     * Can be one of the following: "normal", "break-all", "keep-all", "break-word".
     * Example: "normal"
     */
    word_break: "normal" | "break-all" | "keep-all" | "break-word";

    /**
     * The description of the word break property.
     * Example: "This property defines how words should be broken at the end of a line."
     */
    description: string;
}

export const WORD_BREAK_PROPERTY_FIELDS = [
    "word_break",
    "description"
];
//#endregion

//#region data-files/v10.0.0/auxiliary/WordBreakTest.txt
/**
 * Interface representing the WordBreakTest data structure.
 */
export interface WordBreakTest {
    /**
     * A string containing hex Unicode code points.
     * Example: "0041 0042 0043"
     */
    code_points: string;
    /**
     * An optional comment associated with the code points.
     * Example: "# This is a comment"
     */
    comment?: string;
}

export const WORD_BREAK_TEST_FIELDS = [
    "code_points",
    "comment"
];
//#endregion

