// This file is generated by ucd codegen. Do not edit this file directly.
// Unicode Version: 5.1

//#region data-files/v5.1.0/ArabicShaping.txt
/**
 * This interface defines the shaping classes for Arabic and Syriac positional shaping.
 */
export interface ArabicShaping {
    /**
     * The code point, in 4-digit hexadecimal form, of an Arabic or Syriac character.
     * Example: "0629"
     */
    code_point: string;

    /**
     * A short schematic name for that character, abbreviated from the normative Unicode character name.
     * Example: "TEH MARBUTA"
     */
    short_name: string;

    /**
     * Defines the joining type of the character.
     * Possible values: "R", "L", "D", "C", "U", "T"
     * - R: Right_Joining
     * - L: Left_Joining
     * - D: Dual_Joining
     * - C: Join_Causing
     * - U: Non_Joining
     * - T: Transparent
     */
    joining_type: "R" | "L" | "D" | "C" | "U" | "T";

    /**
     * Defines the joining group based on character names, with parts joined by underscores.
     * Example: "Teh_Marbuta"
     */
    joining_group: string;
}

export const ARABIC_SHAPING_FIELDS = [
    "code_point",
    "short_name",
    "joining_type",
    "joining_group"
];
//#endregion

//#region data-files/v5.1.0/BidiMirroring.txt
/**
 * Interface representing the Bidi_Mirroring_Glyph Property data.
 */
export interface BidiMirroring {
    /**
     * The code point of the original character represented as a hexadecimal value.
     * Example: '0041' for 'A'.
     */
    original_code_point: string;

    /**
     * The code point of the mirrored character represented as a hexadecimal value.
     * Example: '0061' for 'a'.
     */
    mirrored_code_point: string;
}

export const BIDI_MIRRORING_FIELDS = [
    "original_code_point",
    "mirrored_code_point"
];
//#endregion

//#region data-files/v5.1.0/Blocks.txt
/**
 * Interface representing Unicode character blocks.
 */
export interface Blocks {
    /**
     * The starting code point of the block.
     * Format: U+XXXX (e.g., U+0041 for 'A')
     */
    start_code: string;

    /**
     * The ending code point of the block.
     * Format: U+XXXX (e.g., U+007A for 'z')
     */
    end_code: string;

    /**
     * The name of the block.
     * Example: "Basic Latin"
     */
    block_name: string;
}

export const BLOCKS_FIELDS = ["start_code", "end_code", "block_name"];
//#endregion

//#region data-files/v5.1.0/CaseFolding.txt
/**
 * This interface represents the case folding properties as defined in the Unicode Character Database.
 */
export interface CaseFolding {
    /**
     * The Unicode code point of the character.
     * Format: Hexadecimal (e.g., U+0041 for 'A').
     */
    code: string;

    /**
     * The status of the case folding mapping.
     * Possible values: "C" (common), "F" (full), "S" (simple), "T" (Turkic special case).
     */
    status: "C" | "F" | "S" | "T";

    /**
     * The mapping for the case folding.
     * Format: A single character or multiple characters separated by spaces.
     * Example: "a" for simple case folding, "Ã¤ a" for full case folding.
     */
    mapping: string;

    /**
     * The name of the character.
     * This is a descriptive name for the character represented by the code point.
     */
    name: string;
}

export const CASE_FOLDING_FIELDS = [
    "code",
    "status",
    "mapping",
    "name"
];
//#endregion

//#region data-files/v5.1.0/CompositionExclusions.txt
/**
 * This interface represents the Composition Exclusions defined in UAX #15, Unicode Normalization Forms.
 */
export interface CompositionExclusions {
    /**
     * The date when the file was created or last modified.
     * Format: YYYY-MM-DD, HH:MM:SS TZ
     * Example: "2008-03-20, 17:45:00 PDT"
     */
    date: string;

    /**
     * A description of the file's purpose and content.
     * Example: "This file lists the characters for the Composition Exclusion Table"
     */
    description: string;

    /**
     * The copyright information for the file.
     * Example: "Copyright (c) 1991-2008 Unicode, Inc."
     */
    copyright: string;

    /**
     * The URL for the terms of use.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use_url: string;

    /**
     * The URL for more information about the Unicode report.
     * Example: "http://www.unicode.org/unicode/reports/tr15/#Primary Exclusion List Table"
     */
    report_url: string;

    /**
     * A reference to the derived property for composition exclusions.
     * Example: "Full_Composition_Exclusion in DerivedNormalizationProps.txt"
     */
    derived_property_reference: string;
}

export const COMPOSITION_EXCLUSIONS_FIELDS = [
    "date",
    "description",
    "copyright",
    "terms_of_use_url",
    "report_url",
    "derived_property_reference"
];
//#endregion

//#region data-files/v5.1.0/DerivedAge.txt
/**
 * This interface represents the derived properties of Unicode characters, specifically focusing on the age at which various code points were first assigned.
 */
export interface DerivedAge {
    /**
     * The version of Unicode in which the code point was assigned.
     * Example: "1.1"
     */
    version: "1.1" | "2.0" | "3.0" | "3.1";

    /**
     * The code point that was assigned a character.
     * Example: "U+0041" for the character 'A'
     */
    code_point: string;

    /**
     * The type of the code point, which can be graphic, format, control, private-use, surrogate, or noncharacter.
     * Example: "graphic"
     */
    code_point_type: "graphic" | "format" | "control" | "private-use" | "surrogate" | "noncharacter";

    /**
     * Indicates whether the code point is a noncharacter or a surrogate.
     * Example: true for noncharacter code points
     */
    is_noncharacter: boolean;

    /**
     * The date and time when the code point was assigned.
     * Example: "2008-03-03T21:57:14Z"
     */
    assigned_date: string;
}

export const DERIVED_AGE_FIELDS = [
    "version",
    "code_point",
    "code_point_type",
    "is_noncharacter",
    "assigned_date"
];
//#endregion

//#region data-files/v5.1.0/DerivedCoreProperties.txt
/**
 * Interface representing the derived core properties from the Unicode Character Database.
 */
export interface DerivedCoreProperties {
    /**
     * The Unicode character's general category.
     * Example: "Lu" for uppercase letters.
     */
    general_category: "Lu" | "Ll" | "Lt" | "Lm" | "Lo" | "Mn" | "Mc" | "Me" | "Nd" | "Nl" | "No" | "Pc" | "Pd" | "Ps" | "Pe" | "Pi" | "Pf" | "Po" | "Sm" | "Sc" | "Sk" | "So" | "Zs" | "Zl" | "Zp";

    /**
     * The Unicode character's script.
     * Example: "Latin" for Latin script characters.
     */
    script: "Latin" | "Cyrillic" | "Arabic" | "Han" | "Greek" | "Hebrew" | "Thai" | "Devanagari" | "Bengali" | "Gurmukhi" | "Gujarati" | "Oriya" | "Tamil" | "Telugu" | "Kannada" | "Malayalam" | "Sinhala" | "Tibetan" | "Myanmar" | "Khmer" | "Lao" | "Vietnamese" | "Syriac" | "Armenian" | "Georgian" | "Cherokee" | "Ethiopic" | "Ogham" | "Runic" | "Deseret" | "Symbol";

    /**
     * The Unicode character's bidirectional category.
     * Example: "L" for left-to-right characters.
     */
    bidirectional_category: "L" | "R" | "AL" | "EN" | "ES" | "ET" | "AN" | "CS" | "NSM" | "B";

    /**
     * The Unicode character's numeric value, if applicable.
     * Example: "1.5" for characters that represent numeric values.
     */
    numeric_value?: string;

    /**
     * The Unicode character's combining class.
     * Example: "0" for characters that do not combine with others.
     */
    combining_class: number;

    /**
     * The Unicode character's uppercase mapping.
     * Example: "A" for lowercase "a".
     */
    uppercase_mapping?: string;

    /**
     * The Unicode character's lowercase mapping.
     * Example: "a" for uppercase "A".
     */
    lowercase_mapping?: string;

    /**
     * The Unicode character's titlecase mapping.
     * Example: "A" for titlecase "a".
     */
    titlecase_mapping?: string;
}

export const DERIVED_CORE_PROPERTIES_FIELDS = [
    "general_category",
    "script",
    "bidirectional_category",
    "numeric_value",
    "combining_class",
    "uppercase_mapping",
    "lowercase_mapping",
    "titlecase_mapping"
];
//#endregion

//#region data-files/v5.1.0/DerivedNormalizationProps.txt
/**
 * Interface representing the properties of DerivedNormalizationProps.
 */
export interface DerivedNormalizationProps {
    /**
     * The normalization form, which can be one of the following: "NFC", "NFD", "NFKC", "NFKD".
     * Example: "NFC"
     */
    normalization_form: "NFC" | "NFD" | "NFKC" | "NFKD";

    /**
     * A boolean indicating whether to use the default normalization.
     * Example: true
     */
    use_default: boolean;

    /**
     * An optional string that specifies the locale for normalization.
     * Example: "en-US"
     */
    locale?: string;
}

export const DERIVED_NORMALIZATION_PROPS_FIELDS = [
    "normalization_form",
    "use_default",
    "locale"
];
//#endregion

//#region data-files/v5.1.0/EastAsianWidth.txt
/**
 * EastAsianWidth properties interface representing Unicode character width classifications.
 */
export interface EastAsianWidth {
    /**
     * Unicode value of the character.
     * Example: U+4E00
     */
    unicode_value: string;

    /**
     * East Asian Width property of the character.
     * Possible values are:
     * - "N": Not East Asian
     * - "A": Ambiguous
     * - "H": Half-width
     * - "W": Full-width
     * - "F": Full-width (for compatibility)
     * - "Na": Narrow
     * Example: "W"
     */
    east_asian_width: "N" | "A" | "H" | "W" | "F" | "Na";
}

export const EAST_ASIAN_WIDTH_FIELDS = [
    "unicode_value",
    "east_asian_width"
];
//#endregion

//#region data-files/v5.1.0/HangulSyllableType.txt
/**
 * Interface representing the Hangul Syllable Type data.
 */
export interface HangulSyllableType {
    /**
     * The Hangul syllable type code.
     * Format: "HANGUL_SYLLABLE_TYPE_CODE"
     * Example: "L"
     */
    hangul_syllable_type_code: "L" | "V" | "LV" | "LVT";

    /**
     * The description of the syllable type.
     * Format: "DESCRIPTION"
     * Example: "Leading consonant"
     */
    description: string;
}

export const HANGUL_SYLLABLE_TYPE_FIELDS = [
    "hangul_syllable_type_code",
    "description"
];
//#endregion

//#region data-files/v5.1.0/Jamo.txt
/**
 * Interface representing the Jamo Short Name property.
 */
export interface Jamo {
  /**
   * The code point of a combining jamo character in 4-digit hexadecimal form.
   * Example: '1100'
   */
  code_point: string;

  /**
   * The Jamo Short Name as a one-, two-, or three-character ASCII string.
   * Example: 'G', 'GG', 'N'
   */
  jamo_short_name: string;
}

export const JAMO_FIELDS = [
  "code_point",
  "jamo_short_name"
];
//#endregion

//#region data-files/v5.1.0/LineBreak.txt
/**
 * This interface represents the line break properties of Unicode characters.
 *
 * Each entry consists of a Unicode value and its corresponding line break property.
 * The line break property can be one of the following:
 * - Normative: "BK", "CR", "LF", "CM", "SG", "GL", "CB", "SP", "ZW", "NL", "WJ", "JL", "JV", "JT", "H2", "H3"
 * - Informative: "XX", "OP", "CL", "QU", "NS", "EX", "SY", "IS", "PR", "PO", "NU", "AL", "ID", "IN", "HY", "BB", "BA", "SA", "AI", "B2"
 *
 * All code points not explicitly listed are given the value "XX".
 *
 * Characters ranges are specified as for other property files in the Unicode Character Database.
 *
 * @example
 * const lineBreak: LineBreak = { unicode_value: 'U+000A', line_break_property: 'LF' };
 */
export interface LineBreak {
    /**
     * The Unicode value of the character.
     *
     * This value is represented in the format 'U+XXXX', where 'XXXX' is the hexadecimal code point.
     * @example 'U+000A'
     */
    unicode_value: string;

    /**
     * The line break property of the character.
     *
     * This property can be one of the following:
     * - Normative: "BK", "CR", "LF", "CM", "SG", "GL", "CB", "SP", "ZW", "NL", "WJ", "JL", "JV", "JT", "H2", "H3"
     * - Informative: "XX", "OP", "CL", "QU", "NS", "EX", "SY", "IS", "PR", "PO", "NU", "AL", "ID", "IN", "HY", "BB", "BA", "SA", "AI", "B2"
     *
     * @example 'LF'
     */
    line_break_property: "BK" | "CR" | "LF" | "CM" | "SG" | "GL" | "CB" | "SP" | "ZW" | "NL" | "WJ" | "JL" | "JV" | "JT" | "H2" | "H3" | "XX" | "OP" | "CL" | "QU" | "NS" | "EX" | "SY" | "IS" | "PR" | "PO" | "NU" | "AL" | "ID" | "IN" | "HY" | "BB" | "BA" | "SA" | "AI" | "B2";
}

export const LINE_BREAK_FIELDS = ["unicode_value", "line_break_property"];
//#endregion

//#region data-files/v5.1.0/NameAliases.txt
/**
 * This interface defines the formal name aliases for Unicode characters.
 * Each alias is associated with a specific code point.
 */
export interface NameAliases {
    /**
     * The Unicode code point of the character, represented in hexadecimal format.
     * Example: "U+0041" for the character 'A'.
     */
    code_point: string;

    /**
     * The alias assigned to the Unicode character.
     * Example: "LATIN CAPITAL LETTER A" for the character 'A'.
     */
    alias: string;
}

export const NAME_ALIASES_FIELDS = ["code_point", "alias"];
//#endregion

//#region data-files/v5.1.0/NamedSequences.txt
/**
 * Interface representing the NamedSequences data structure.
 */
export interface NamedSequences {
    /**
     * The name of the sequence.
     * Example: "Latin Capital Letter A"
     */
    name: string;
    /**
     * The code point sequence for USI.
     * Example: "U+0041"
     */
    code_point_sequence: string;
}

export const NAMED_SEQUENCES_FIELDS = [
    "name",
    "code_point_sequence"
];
//#endregion

//#region data-files/v5.1.0/NamedSequencesProv.txt
/**
 * Provisional Named Sequences
 *
 * This interface represents the provisional named sequences as defined in the Unicode Character Database.
 */
export interface NamedSequencesProv {
    /**
     * The name of the sequence.
     * Example: "Some Sequence Name"
     */
    name_of_sequence: string;

    /**
     * The code point sequence for USI.
     * Format: A sequence of code points represented as a string.
     * Example: "U+0041 U+0042 U+0043"
     */
    code_point_sequence: string;
}

export const NAMED_SEQUENCES_PROV_FIELDS = [
    "name_of_sequence",
    "code_point_sequence"
];
//#endregion

//#region data-files/v5.1.0/NormalizationCorrections.txt
/**
 * This interface represents the normalization corrections as specified in the Unicode Character Database.
 */
export interface NormalizationCorrections {
    /**
     * Unicode code point, represented as a hexadecimal string (e.g., "U+0041").
     */
    unicode_code_point: string;
    /**
     * Original (erroneous) decomposition of the character.
     */
    original_decomposition: string;
    /**
     * Corrected decomposition of the character.
     */
    corrected_decomposition: string;
    /**
     * Version of Unicode for which the correction was entered, in n.n.n format (e.g., "5.1.0").
     */
    unicode_version: string;
    /**
     * Indicates the Unicode Corrigendum which documents the correction.
     */
    comment: string;
}

export const NORMALIZATION_CORRECTIONS_FIELDS = [
    "unicode_code_point",
    "original_decomposition",
    "corrected_decomposition",
    "unicode_version",
    "comment"
];
//#endregion

//#region data-files/v5.1.0/NormalizationTest.txt
/**
 * Interface representing the normalization test suite for Unicode character database.
 */
export interface NormalizationTest {
  /**
   * Conformance for NFC normalization.
   * Must satisfy: c2 == NFC(c1) == NFC(c2) == NFC(c3)
   * Example: If c1 is 'a', c2 must be the NFC of 'a'.
   */
  c2: string;

  /**
   * Conformance for NFD normalization.
   * Must satisfy: c3 == NFD(c1) == NFD(c2) == NFD(c3)
   * Example: If c1 is 'a', c3 must be the NFD of 'a'.
   */
  c3: string;

  /**
   * Conformance for NFKC normalization.
   * Must satisfy: c4 == NFKC(c1) == NFKC(c2) == NFKC(c3) == NFKC(c4) == NFKC(c5)
   * Example: If c1 is 'a', c4 must be the NFKC of 'a'.
   */
  c4: string;

  /**
   * Conformance for NFKD normalization.
   * Must satisfy: c5 == NFKD(c1) == NFKD(c2) == NFKD(c3) == NFKD(c4) == NFKD(c5)
   * Example: If c1 is 'a', c5 must be the NFKD of 'a'.
   */
  c5: string;

  /**
   * Code point X must satisfy: X == NFC(X) == NFD(X) == NFKC(X) == NFKD(X)
   * Example: If X is a valid Unicode character, it must remain unchanged by any normalization.
   */
  X: string;
}

export const NORMALIZATION_TEST_FIELDS = [
  "c2",
  "c3",
  "c4",
  "c5",
  "X"
];
//#endregion

//#region data-files/v5.1.0/PropList.txt
/**
 * Interface representing the Unicode Character Database properties.
 */
export interface PropList {
    /**
     * The date of the file creation in GMT format.
     * Example: "2008-03-20, 17:55:27 GMT"
     */
    date: string;
    /**
     * The copyright information for the Unicode Character Database.
     * Example: "Copyright (c) 1991-2008 Unicode, Inc."
     */
    copyright: string;
    /**
     * The terms of use for the Unicode Character Database.
     * Example: "For terms of use, see http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;
    /**
     * The documentation reference for the Unicode Character Database.
     * Example: "For documentation, see UCD.html"
     */
    documentation: string;
}

export const PROP_LIST_FIELDS = [
    "date",
    "copyright",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v5.1.0/PropertyAliases.txt
/**
 * This interface defines the property aliases used in the Unicode Character Database (UCD).
 *
 * The properties include:
 * - abbreviated_name: A short name for the property.
 * - long_name: A detailed name for the property.
 * - additional_aliases: Any other aliases that may be useful.
 *
 * Note: Property value names are not unique across properties, and some property names may be the same as property value names.
 *
 * Example of property value and property name uniqueness:
 * - AL means Arabic Letter for the Bidi_Class property.
 * - AL means Alpha_Left for the Combining_Class property.
 * - AL means Alphabetic for the Line_Break property.
 */
export interface PropertyAliases {
  abbreviated_name: string;
  long_name: string;
  additional_aliases?: string[];
}

export const PROPERTY_ALIASES_FIELDS = [
  "abbreviated_name",
  "long_name",
  "additional_aliases"
];
//#endregion

//#region data-files/v5.1.0/PropertyValueAliases.txt
/**
 * This interface defines the property value aliases used in the Unicode Character Database.
 * Each property value is associated with a specific property and may have multiple aliases.
 *
 * The properties include:
 * - property: The name of the property for which the value is used.
 * - abbreviated_name: A short form of the property value name, or 'n/a' if not available.
 * - long_name: A detailed description of the property value.
 *
 * Note: Property value names are not unique across properties, and some property names may be the same as property value names.
 *
 * Example:
 * - property: 'Bidi_Class'
 * - abbreviated_name: 'AL'
 * - long_name: 'Arabic Letter'
 */
export interface PropertyValueAliases {
  property: string;
  abbreviated_name: "n/a" | string;
  long_name: string;
}

export const PROPERTY_VALUE_ALIASES_FIELDS = [
  "property",
  "abbreviated_name",
  "long_name"
];
//#endregion

//#region data-files/v5.1.0/Scripts.txt
/**
 * Unicode Character Database
 *
 * @property {string} date - The date of the file creation in the format "YYYY-MM-DD, HH:MM:SS GMT". Example: "2008-03-20, 17:55:33 GMT"
 * @property {string} copyright - The copyright information. Example: "Copyright (c) 1991-2008 Unicode, Inc."
 * @property {string} terms_of_use - The URL for terms of use. Example: "http://www.unicode.org/terms_of_use.html"
 * @property {string} documentation - The URL for documentation. Example: "UCD.html"
 */
export interface Scripts {
    date: string;
    copyright: string;
    terms_of_use: string;
    documentation: string;
}

export const SCRIPTS_FIELDS = [
    "date",
    "copyright",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v5.1.0/SpecialCasing.txt
/**
 * This interface represents the special casing properties of Unicode characters.
 */
export interface SpecialCasing {
    /**
     * The Unicode code point of the character in hexadecimal format.
     * Example: "0041" for 'A'
     */
    code: string;

    /**
     * The lowercase mapping of the character in hexadecimal format.
     * Example: "0061" for 'a'
     */
    lower: string;

    /**
     * The titlecase mapping of the character in hexadecimal format.
     * Example: "0041" for 'A'
     */
    title: string;

    /**
     * The uppercase mapping of the character in hexadecimal format.
     * Example: "0041" for 'A'
     */
    upper: string;

    /**
     * An optional list of conditions that override normal behavior.
     * Example: "en" for English, "Not_fr" for not French
     */
    condition_list?: string;

    /**
     * A comment providing additional information about the entry.
     */
    comment?: string;
}

export const SPECIAL_CASING_FIELDS = [
    "code",
    "lower",
    "title",
    "upper",
    "condition_list",
    "comment"
];
//#endregion

//#region data-files/v5.1.0/StandardizedVariants.txt
/**
 * StandardizedVariants
 *
 * This interface represents the standardized variation sequences defined in the Unicode Standard.
 */
export interface StandardizedVariants {
  /**
   * The variation sequence.
   * Example: "U+E0100 U+E0101"
   */
  variation_sequence: string;

  /**
   * The description of the desired appearance.
   * Example: "This character appears as a bold version."
   */
  description: string;

  /**
   * Indicates where the appearance is only different in particular shaping environments.
   * Example: "This character may appear differently in a specific font."
   */
  shaping_environments: string;
}

export const STANDARDIZED_VARIANTS_FIELDS = [
  "variation_sequence",
  "description",
  "shaping_environments"
];
//#endregion

//#region data-files/v5.1.0/extracted/DerivedBidiClass.txt
/**
 * Interface representing the Unicode Character Database derived from the file DerivedBidiClass.
 */
export interface DerivedBidiClass {
    /**
     * The Unicode character code point, represented as a hexadecimal string.
     * Example: "U+0041" for the character 'A'.
     */
    code_point: string;

    /**
     * The bidirectional category of the character.
     * Example: "L" for Left-to-Right, "R" for Right-to-Left.
     */
    bidi_category: "L" | "R" | "AL" | "EN" | "ES" | "ET" | "AN" | "CS" | "NSM" | "B" | "S" | "WS";

    /**
     * The mirrored character code point, if applicable.
     * Example: "U+005B" for the character '[' which mirrors to ']'.
     */
    mirrored_code_point?: string;

    /**
     * Indicates whether the character is a control character.
     * Example: true for characters like U+0000 (NULL).
     */
    is_control: boolean;
}

export const DERIVED_BIDI_CLASS_FIELDS = [
    "code_point",
    "bidi_category",
    "mirrored_code_point",
    "is_control"
];
//#endregion

//#region data-files/v5.1.0/extracted/DerivedBinaryProperties.txt
/**
 * Interface representing the derived binary properties from the Unicode Character Database.
 */
export interface DerivedBinaryProperties {
    /**
     * Indicates whether the character is a control character.
     * Example: "true" or "false"
     */
    control: "true" | "false";

    /**
     * Indicates whether the character is a digit.
     * Example: "true" or "false"
     */
    digit: "true" | "false";

    /**
     * Indicates whether the character is a letter.
     * Example: "true" or "false"
     */
    letter: "true" | "false";

    /**
     * Indicates whether the character is a punctuation mark.
     * Example: "true" or "false"
     */
    punctuation: "true" | "false";

    /**
     * Indicates whether the character is a whitespace character.
     * Example: "true" or "false"
     */
    whitespace: "true" | "false";
}

export const DERIVED_BINARY_PROPERTIES_FIELDS = [
    "control",
    "digit",
    "letter",
    "punctuation",
    "whitespace"
];
//#endregion

//#region data-files/v5.1.0/extracted/DerivedCombiningClass.txt
/**
 * Interface representing the Unicode Character Database derived combining class.
 */
export interface DerivedCombiningClass {
    /**
     * The date of the document in ISO 8601 format.
     * Example: "2008-03-20T17:54:45Z"
     */
    date: string;

    /**
     * The copyright information for the Unicode Character Database.
     * Example: "Copyright (c) 1991-2008 Unicode, Inc."
     */
    copyright: string;

    /**
     * The terms of use URL for the Unicode Character Database.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;

    /**
     * The documentation URL for the Unicode Character Database.
     * Example: "UCD.html"
     */
    documentation: string;
}

export const DERIVED_COMBINING_CLASS_FIELDS = [
    "date",
    "copyright",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v5.1.0/extracted/DerivedDecompositionType.txt
/**
 * Interface representing the Unicode Character Database derived decomposition type.
 */
export interface DerivedDecompositionType {
    /**
     * The character that is decomposed.
     * Example: 'A'
     */
    decomposed_character: string;
    
    /**
     * The decomposition mapping for the character.
     * Example: 'A' -> 'A, B'
     */
    decomposition_mapping: string;
    
    /**
     * The type of decomposition.
     * Example: 'canonical' or 'compat'
     */
    decomposition_type: "canonical" | "compat";
}

export const DERIVED_DECOMPOSITION_TYPE_FIELDS = [
    "decomposed_character",
    "decomposition_mapping",
    "decomposition_type"
];
//#endregion

//#region data-files/v5.1.0/extracted/DerivedEastAsianWidth.txt
/**
 * Interface representing the Derived East Asian Width data.
 */
export interface DerivedEastAsianWidth {
    /**
     * The character code point in hexadecimal format.
     * Example: "U+0041" for the character 'A'.
     */
    code_point: string;

    /**
     * The East Asian Width property of the character.
     * Possible values: "N", "A", "H", "W", "F", "Na".
     */
    east_asian_width: "N" | "A" | "H" | "W" | "F" | "Na";
}

export const DERIVED_EAST_ASIAN_WIDTH_FIELDS = [
    "code_point",
    "east_asian_width"
];
//#endregion

//#region data-files/v5.1.0/extracted/DerivedGeneralCategory.txt
/**
 * Interface representing the derived general category from the Unicode Character Database.
 */
export interface DerivedGeneralCategory {
    /**
     * The general category of the character.
     * Example: "Lu" for uppercase letters.
     */
    general_category: "Lu" | "Ll" | "Lt" | "Lm" | "Lo" | "Mn" | "Mc" | "Me" | "Nd" | "Nl" | "No" | "Pc" | "Pd" | "Ps" | "Pe" | "Pi" | "Pf" | "Po" | "Sm" | "Sc" | "Sk" | "So" | "Zs" | "Zl" | "Zp";

    /**
     * The Unicode code point of the character.
     * Example: 65 for 'A'.
     */
    code_point: number;

    /**
     * The name of the character.
     * Example: "LATIN CAPITAL LETTER A".
     */
    character_name: string;
}

export const DERIVED_GENERAL_CATEGORY_FIELDS = [
    "general_category",
    "code_point",
    "character_name"
];
//#endregion

//#region data-files/v5.1.0/extracted/DerivedJoiningGroup.txt
/**
 * Interface representing the Unicode Character Database derived joining group.
 */
export interface DerivedJoiningGroup {
    /**
     * The name of the derived joining group.
     * Example: "Left"
     */
    derived_joining_group_name: string;

    /**
     * The characters that belong to this derived joining group.
     * Example: "U+0020, U+0021"
     */
    characters: string;

    /**
     * The type of joining for the characters in this group.
     * Example: "D" for dual, "L" for left, "R" for right
     */
    joining_type: "D" | "L" | "R";
}

export const DERIVED_JOINING_GROUP_FIELDS = [
    "derived_joining_group_name",
    "characters",
    "joining_type"
];
//#endregion

//#region data-files/v5.1.0/extracted/DerivedJoiningType.txt
/**
 * @property {string} unicode_character_database - The database containing Unicode character information.
 * @property {string} date - The date and time when the document was created, formatted as YYYY-MM-DD, HH:MM:SS GMT.
 * @property {string} copyright - The copyright information for the Unicode Character Database.
 * @property {string} terms_of_use - The URL for the terms of use for the Unicode Character Database.
 * @property {string} documentation - The URL for the documentation of the Unicode Character Database.
 */
export interface DerivedJoiningType {
  unicode_character_database: string;
  date: string;
  copyright: string;
  terms_of_use: string;
  documentation: string;
}

export const DERIVED_JOINING_TYPE_FIELDS = [
  "unicode_character_database",
  "date",
  "copyright",
  "terms_of_use",
  "documentation"
];
//#endregion

//#region data-files/v5.1.0/extracted/DerivedLineBreak.txt
/**
 * Interface representing the Unicode Character Database derived line break properties.
 */
export interface DerivedLineBreak {
    /**
     * The date when the data was last updated.
     * Format: YYYY-MM-DD, HH:MM:SS GMT
     * Example: "2008-03-20, 17:55:02 GMT"
     */
    date: string;

    /**
     * The copyright information for the Unicode Character Database.
     * Example: "Copyright (c) 1991-2008 Unicode, Inc."
     */
    copyright: string;

    /**
     * The terms of use for the Unicode Character Database.
     * Example: "For terms of use, see http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;

    /**
     * The documentation reference for the Unicode Character Database.
     * Example: "For documentation, see UCD.html"
     */
    documentation: string;
}

export const DERIVED_LINE_BREAK_FIELDS = [
    "date",
    "copyright",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v5.1.0/extracted/DerivedNumericType.txt
/**
 * Interface representing the Unicode Character Database derived numeric types.
 */
export interface DerivedNumericType {
    /**
     * The numeric value associated with the character.
     * Example: 1.0
     */
    value: number;
    /**
     * The type of the numeric value.
     * Example: "integer" or "decimal"
     */
    type: "integer" | "decimal";
    /**
     * The character associated with the numeric value.
     * Example: 'A'
     */
    character: string;
}

export const DERIVED_NUMERIC_TYPE_FIELDS = [
    "value",
    "type",
    "character"
];
//#endregion

//#region data-files/v5.1.0/extracted/DerivedNumericValues.txt
/**
 * Interface representing the derived numeric values from the Unicode Character Database.
 */
export interface DerivedNumericValues {
    /**
     * The numeric value associated with a character.
     * Example: "1.0"
     */
    numeric_value: "string";
    
    /**
     * The type of numeric value.
     * Example: "integer" or "decimal"
     */
    numeric_type: "string";
    
    /**
     * The character associated with the numeric value.
     * Example: "A"
     */
    character: "string";
}

export const DERIVED_NUMERIC_VALUES_FIELDS = [
    "numeric_value",
    "numeric_type",
    "character"
];
//#endregion

//#region data-files/v5.1.0/auxiliary/GraphemeBreakProperty.txt
/**
 * Interface representing the GraphemeBreakProperty data.
 */
export interface GraphemeBreakProperty {
    /**
     * The Unicode character.
     * Example: 'A'
     */
    character: string;
    /**
     * The grapheme break property of the character.
     * Example: 'CR' (Carriage Return)
     */
    property: "CR" | "LF" | "Control" | "Extend" | "ZWS" | "Regional_Indicator" | "Prepend" | "SpacingMark" | "L" | "V" | "T" | "LV" | "LVT";
}

export const GRAPHEME_BREAK_PROPERTY_FIELDS = [
    "character",
    "property"
];
//#endregion

//#region data-files/v5.1.0/auxiliary/GraphemeBreakTest.txt
/**
 * GraphemeBreakTest interface representing the default grapheme break test data.
 */
export interface GraphemeBreakTest {
    /**
     * A string containing hex Unicode code points.
     * Example: "0041 0042 0043"
     */
    code_points: string;
    /**
     * An optional comment associated with the code points.
     * Example: "# This is a comment"
     */
    comment?: string;
}

export const GRAPHEME_BREAK_TEST_FIELDS = [
    "code_points",
    "comment"
];
//#endregion

//#region data-files/v5.1.0/auxiliary/LineBreakTest.txt
/**
 * Default Line Break Test
 */
export interface LineBreakTest {
    /**
     * The string containing hex Unicode code points.
     * Format: <string> (# <comment>)?
     * Example: "0041 0042 0043"
     */
    string: string;
    /**
     * An optional comment associated with the string.
     * Format: # <comment>
     * Example: "# This is a comment"
     */
    comment?: string;
}

export const LINE_BREAK_TEST_FIELDS = [
    "string",
    "comment"
];
//#endregion

//#region data-files/v5.1.0/auxiliary/SentenceBreakProperty.txt
/**
 * Interface representing the SentenceBreakProperty.
 */
export interface SentenceBreakProperty {
    /**
     * The property value for the sentence break.
     * It can be one of the following: "CR", "LF", "Control", "Sep", "Format", "Sp", "Lower", "Upper", "ATerm", "STerm", "OTerm", "Other".
     * Example: "CR" indicates a carriage return.
     */
    property_value: "CR" | "LF" | "Control" | "Sep" | "Format" | "Sp" | "Lower" | "Upper" | "ATerm" | "STerm" | "OTerm" | "Other";
}

export const SENTENCE_BREAK_PROPERTY_FIELDS = [
    "property_value"
];
//#endregion

//#region data-files/v5.1.0/auxiliary/SentenceBreakTest.txt
/**
 * Interface representing the default sentence break test data.
 */
export interface SentenceBreakTest {
    /**
     * A string containing hex Unicode code points.
     * Example: "0041 0042 0043"
     */
    string: string;

    /**
     * An optional comment associated with the string.
     * Example: "# This is a comment"
     */
    comment?: string;
}

export const SENTENCE_BREAK_TEST_FIELDS = [
    "string",
    "comment"
];
//#endregion

//#region data-files/v5.1.0/auxiliary/WordBreakProperty.txt
/**
 * Interface representing the WordBreakProperty.
 */
export interface WordBreakProperty {
    /**
     * Represents the word break property for a character.
     * Possible values are:
     * - "normal": Default word breaking.
     * - "break-all": Break words at any character.
     * - "keep-all": Do not break words.
     * Example: "normal"
     */
    word_break: "normal" | "break-all" | "keep-all";
}

export const WORD_BREAK_PROPERTY_FIELDS = [
    "word_break"
];
//#endregion

//#region data-files/v5.1.0/auxiliary/WordBreakTest.txt
/**
 * Interface representing the Word Break Test data.
 */
export interface WordBreakTest {
    /**
     * A string containing hex Unicode code points.
     * Example: "0041 0042 0043"
     */
    string: string;
    /**
     * An optional comment associated with the string.
     * Example: "# This is a comment"
     */
    comment?: string;
}

export const WORD_BREAK_TEST_FIELDS = [
    "string",
    "comment"
];
//#endregion

