// This file is generated by ucd codegen. Do not edit this file directly.
// Unicode Version: 16


// #region ArabicShaping
export interface ArabicShaping {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
  joining_type: "R" | "L" | "D" | "C" | "U" | "T"; // Defines the joining type (R = Right_Joining, L = Left_Joining, D = Dual_Joining, C = Join_Causing, U = Non_Joining, T = Transparent)
  joining_group: string; // Defines the joining group, based schematically on character names
}

export const ARABIC_SHAPING_FIELDS = [
  "code_point",
  "name",
  "joining_type",
  "joining_group"
];

// #endregion

// #region BidiBrackets
export interface BidiBrackets {
  unicode_code_point: string; // Unicode code point value, represented as a hexadecimal value
  bidi_paired_bracket: string | "none"; // Bidi_Paired_Bracket property value, a code point value or none
  bidi_paired_bracket_type: "o" | "c" | "n"; // Bidi_Paired_Bracket_Type property value, which can be Open (o), Close (c), or None (n)
}

export const BIDI_BRACKETS_FIELDS = [
  "unicode_code_point",
  "bidi_paired_bracket",
  "bidi_paired_bracket_type"
];

// #endregion

// #region BidiMirroring
export interface BidiMirroring {
  bidi_mirroring_glyph: "none" | string; // The mapping of a code point to its mirrored glyph, or none if no mapping exists.
}

export const BIDI_MIRRORING_FIELDS = [
  "bidi_mirroring_glyph"
];

// #endregion

// #region Blocks
export interface Blocks {
  start_code: string; // The starting code point of the block, in hexadecimal form
  end_code: string; // The ending code point of the block, in hexadecimal form
  block_name: string; // The name of the Unicode block
}

export const BLOCKS_FIELDS = [
  "start_code",
  "end_code",
  "block_name"
];

// #endregion

// #region CJKRadicals
export interface CjkRadicals {
  cjk_radical_number: string; // The CJK radical number, matching the regular expression [1-9][0-9]{0,2}'{0,2}
  cjk_radical_character: string; // The CJK radical character, which may be empty if not included in the relevant blocks
  cjk_unified_ideograph: string; // The CJK unified ideograph formed from the radical
}

export const CJK_RADICALS_FIELDS = [
  "cjk_radical_number",
  "cjk_radical_character",
  "cjk_unified_ideograph"
];

// #endregion

// #region CaseFolding
export interface CaseFolding {
  code_point: string; // The code point of a character, in hexadecimal form
  status: "C" | "F" | "S" | "T"; // The status of the case folding mapping, indicating the type of mapping used
  mapping: string; // The case folding mapping for the character, which may include multiple characters for full case folding
  name: string; // A short schematic name for the character
}

export const CASE_FOLDING_FIELDS = [
  "code_point",
  "status",
  "mapping",
  "name"
];

// #endregion

// #region CompositionExclusions
export interface CompositionExclusions {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
}

export const COMPOSITION_EXCLUSIONS_FIELDS = [
  "code_point",
  "name"
];

// #endregion

// #region DerivedAge
export interface DerivedAge {
  type_name: string; // The name of the derived property type
}

export const DERIVED_AGE_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedCoreProperties
export interface DerivedCoreProperties {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const DERIVED_CORE_PROPERTIES_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedNormalizationProps
export interface DerivedNormalizationProps {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
  joining_type: "R" | "L" | "D" | "C" | "U" | "T"; // Defines the joining type (R = Right_Joining, L = Left_Joining, D = Dual_Joining, C = Join_Causing, U = Non_Joining, T = Transparent)
  joining_group: string; // Defines the joining group, based schematically on character names
}

export const DERIVED_NORMALIZATION_PROPS_FIELDS = [
  "code_point",
  "name",
  "joining_type",
  "joining_group"
];

// #endregion

// #region DoNotEmit
export interface DoNotEmit {
  do_not_emit_sequence: string; // A sequence of Unicode code point values that should not be emitted or generated in newly authored text.
  replacement_sequence: string; // A replacement sequence of Unicode code point values for the discouraged sequence.
  do_not_emit_type: "Indic_Atomic_Consonant" | "Indic_Consonant_Conjunct" | "Indic_Vowel_Letter" | "Bengali_Khanda_Ta" | "Malayalam_Chillu" | "Tamil_Shrii" | "Dotless_Form" | "Hamza_Form" | "Precomposed_Form" | "Deprecated" | "Discouraged" | "Preferred_Spelling"; // The type of the original character sequence that is discouraged.
  comment: string; // An optional human-readable comment field providing additional information about the sequence.
}

export const DO_NOT_EMIT_FIELDS = [
  "do_not_emit_sequence",
  "replacement_sequence",
  "do_not_emit_type",
  "comment"
];

// #endregion

// #region EastAsianWidth
export interface EastAsianWidth {
  unicode_code_point: string; // Unicode code point value or range of code point values
  east_asian_width: "A" | "F" | "H" | "N" | "Na" | "W"; // East Asian Width property, indicating the width category of the character
}

export const EAST_ASIAN_WIDTH_FIELDS = [
  "unicode_code_point",
  "east_asian_width"
];

// #endregion

// #region EmojiSources
export interface EmojiSources {
  unicode_code_point_or_sequence: string; // The Unicode code point or sequence.
  docomo_shift_jis_code: string; // The DoCoMo Shift-JIS code for the equivalent symbol.
  kddi_shift_jis_code: string; // The KDDI Shift-JIS code for the equivalent symbol.
  softbank_shift_jis_code: string; // The SoftBank Shift-JIS code for the equivalent symbol.
}

export const EMOJI_SOURCES_FIELDS = [
  "unicode_code_point_or_sequence",
  "docomo_shift_jis_code",
  "kddi_shift_jis_code",
  "softbank_shift_jis_code"
];

// #endregion

// #region EquivalentUnifiedIdeograph
export interface EquivalentUnifiedIdeograph {
  equivalent_unified_ideograph: string; // The property defining the equivalent unified ideograph for a given code point or code point range.
  code_point: string; // A code point or code point range represented as a variable-length hexadecimal value with 4 to 6 digits.
  equivalent_code_point: string; // The equivalent CJK unified ideograph represented as a variable-length hexadecimal value with 4 to 6 digits.
  default_value: "none" | string; // The default value for the Equivalent_Unified_Ideograph property, which is 'none' unless specified otherwise.
}

export const EQUIVALENT_UNIFIED_IDEOGRAPH_FIELDS = [
  "equivalent_unified_ideograph",
  "code_point",
  "equivalent_code_point",
  "default_value"
];

// #endregion

// #region HangulSyllableType
export interface HangulSyllableType {
  hangul_syllable_type: string; // The type of Hangul syllable, indicating its structure and composition.
}

export const HANGUL_SYLLABLE_TYPE_FIELDS = [
  "hangul_syllable_type"
];

// #endregion

// #region IndicPositionalCategory
export interface IndicPositionalCategory {
  unicode_code_point: string; // Unicode code point value or range of code point values
  indic_positional_category: string; // Indic Positional Category property value
}

export const INDIC_POSITIONAL_CATEGORY_FIELDS = [
  "unicode_code_point",
  "indic_positional_category"
];

// #endregion

// #region IndicSyllabicCategory
export interface IndicSyllabicCategory {
  unicode_code_point: string; // Unicode code point value or range of code point values
  indic_syllabic_category: string; // Indic_Syllabic_Category property value
  comment: string; // Comment field showing General_Category property value, Unicode character name(s), and code point count in square brackets if applicable.
}

export const INDIC_SYLLABIC_CATEGORY_FIELDS = [
  "unicode_code_point",
  "indic_syllabic_category",
  "comment"
];

// #endregion

// #region Jamo
export interface Jamo {
  code_point: string; // The code point of a conjoining jamo character, in 4-digit hexadecimal form
  jamo_short_name: string; // The Jamo_Short_Name as a one-, two-, or three-character ASCII string
}

export const JAMO_FIELDS = [
  "code_point",
  "jamo_short_name"
];

// #endregion

// #region LineBreak
export interface LineBreak {
  code_point: string; // Unicode code point value or range of code point values
  line_break_property: "BK" | "CM" | "CR" | "GL" | "LF" | "NL" | "SP" | "WJ" | "ZW" | "ZWJ" | "AI" | "AK" | "AL" | "AP" | "AS" | "B2" | "BA" | "BB" | "CB" | "CJ" | "CL" | "CP" | "EB" | "EM" | "EX" | "H2" | "H3" | "HL" | "HY" | "ID" | "IN" | "IS" | "JL" | "JT" | "JV" | "NS" | "NU" | "OP" | "PO" | "PR" | "QU" | "RI" | "SA" | "SG" | "SY" | "VF" | "VI" | "XX"; // Line_Break property, indicating how line breaks should be handled for the code point
}

export const LINE_BREAK_FIELDS = [
  "code_point",
  "line_break_property"
];

// #endregion

// #region NameAliases
export interface NameAliases {
  code_point: string; // The code point of a character, in hexadecimal form
  alias: string; // The formal name alias for the Unicode character
  type: "correction" | "control" | "alternate" | "figment" | "abbreviation"; // The type of the alias, indicating its purpose or classification
}

export const NAME_ALIASES_FIELDS = [
  "code_point",
  "alias",
  "type"
];

// #endregion

// #region NamedSequences
export interface NamedSequences {
  name_of_sequence: string; // The name of the Unicode named character sequence.
  code_point_sequence: string[]; // The sequence of code points corresponding to the named sequence, represented as an array of strings.
}

export const NAMED_SEQUENCES_FIELDS = [
  "name_of_sequence",
  "code_point_sequence"
];

// #endregion

// #region NamedSequencesProv
export interface NamedSequencesProv {
  name_of_sequence: string; // The name of the Unicode named character sequence.
  code_point_sequence: string[]; // A sequence of code points represented as an array of strings.
}

export const NAMED_SEQUENCES_PROV_FIELDS = [
  "name_of_sequence",
  "code_point_sequence"
];

// #endregion

// #region NormalizationCorrections
export interface NormalizationCorrections {
  unicode_code_point: string; // The Unicode code point of the character, represented in hexadecimal format.
  original_decomposition: string; // The original erroneous decomposition of the character.
  corrected_decomposition: string; // The corrected decomposition of the character.
  unicode_version: string; // The version of Unicode for which the correction was entered, in n.n.n format.
  comment: string; // Indicates the Unicode Corrigendum which documents the correction.
}

export const NORMALIZATION_CORRECTIONS_FIELDS = [
  "unicode_code_point",
  "original_decomposition",
  "corrected_decomposition",
  "unicode_version",
  "comment"
];

// #endregion

// #region NushuSources
export interface NushuSources {
  type_name: string; // The name of the type as specified in the document.
}

export const NUSHU_SOURCES_FIELDS = [
  "type_name"
];

// #endregion

// #region PropList
export interface PropList {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const PROP_LIST_FIELDS = [
  "type_name"
];

// #endregion

// #region PropertyAliases
export interface PropertyAliases {
  short_name: string; // The short name for the property, typically an abbreviation or a duplicate of the long name.
  long_name: string; // The long name for the property, typically the formal name used in documentation.
  aliases: string[]; // Additional aliases for the property that may be useful in various contexts.
}

export const PROPERTY_ALIASES_FIELDS = [
  "short_name",
  "long_name",
  "aliases"
];

// #endregion

// #region PropertyValueAliases
export interface PropertyValueAliases {
  property: string; // The property for which the property value name is used.
  short_name: string; // The short name for the property value, typically an abbreviation.
  long_name: string; // The long name for the property value, typically the formal name used in documentation.
  additional_aliases: string[]; // Other aliases that may be listed in additional fields.
}

export const PROPERTY_VALUE_ALIASES_FIELDS = [
  "property",
  "short_name",
  "long_name",
  "additional_aliases"
];

// #endregion

// #region ScriptExtensions
export interface ScriptExtensions {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
  script_extensions: string[]; // A set of one or more abbreviated Script property values that indicate which characters are commonly used with more than one script
}

export const SCRIPT_EXTENSIONS_FIELDS = [
  "code_point",
  "name",
  "script_extensions"
];

// #endregion

// #region Scripts
export interface Scripts {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const SCRIPTS_FIELDS = [
  "type_name"
];

// #endregion

// #region SpecialCasing
export interface SpecialCasing {
  code: string; // The Unicode code point, expressed as a character value in hex.
  lower: string; // The full lowercase mapping of the code point.
  title: string; // The full titlecase mapping of the code point.
  upper: string; // The full uppercase mapping of the code point.
  condition_list: string[]; // An optional list of language IDs or casing contexts that override normal behavior.
  comment: string; // A comment providing additional information about the entry.
}

export const SPECIAL_CASING_FIELDS = [
  "code",
  "lower",
  "title",
  "upper",
  "condition_list",
  "comment"
];

// #endregion

// #region StandardizedVariants
export interface StandardizedVariants {
  variation_sequence: string; // The variation sequence defined in the Unicode Standard.
  description: string; // The description of the desired appearance for the variation sequence.
  shaping_environment: string; // Specifies where the appearance is only different in particular shaping environments.
}

export const STANDARDIZED_VARIANTS_FIELDS = [
  "variation_sequence",
  "description",
  "shaping_environment"
];

// #endregion

// #region TangutSources
export interface TangutSources {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const TANGUT_SOURCES_FIELDS = [
  "type_name"
];

// #endregion

// #region USourceData
export interface USourceData {
  u_source_identifier: string; // U-source identifier
  status: "Comp" | "ExtA" | "ExtB" | "ExtC" | "ExtD" | "ExtE" | "ExtF" | "ExtG" | "ExtH" | "ExtI" | "FutureWS" | "NoAction" | "Rejected" | "URO" | "Variant" | "WS-2021" | string; // Status of the U-source ideograph
  unicode_code_point: string; // The Unicode code point of this ideograph, or the code point of the related encoded ideograph
  krs_unicode_property: string; // kRSUnicode property value (see UAX #38)
  virtual_kangxi_position: number; // Virtual KangXi dictionary position
  ideographic_description_sequence: string; // Ideographic Description Sequence (IDS)
  sources: string[]; // Sources for the ideograph
  general_comments: string; // General comments about the ideograph
  total_strokes: number; // kTotalStrokes property value (see UAX #38)
  first_residual_stroke: number; // First residual stroke
}

export const U_SOURCE_DATA_FIELDS = [
  "u_source_identifier",
  "status",
  "unicode_code_point",
  "krs_unicode_property",
  "virtual_kangxi_position",
  "ideographic_description_sequence",
  "sources",
  "general_comments",
  "total_strokes",
  "first_residual_stroke"
];

// #endregion

// #region Unikemet
export interface Unikemet {
  type_name: string; // The name of the type, specifically for Unikemet data related to Egyptian Hieroglyphs.
}

export const UNIKEMET_FIELDS = [
  "type_name"
];

// #endregion

// #region VerticalOrientation
export interface VerticalOrientation {
  unicode_code_point: string; // Unicode code point value or range of code point values in hexadecimal form
  vertical_orientation: "U" | "R" | "Tu" | "Tr"; // Vertical_Orientation property value, indicating the orientation of the character
}

export const VERTICAL_ORIENTATION_FIELDS = [
  "unicode_code_point",
  "vertical_orientation"
];

// #endregion

// #region DerivedBidiClass
export interface DerivedBidiClass {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const DERIVED_BIDI_CLASS_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedBinaryProperties
export interface DerivedBinaryProperties {
  type_name: string; // The name of the type as defined in the Unicode data file.
}

export const DERIVED_BINARY_PROPERTIES_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedCombiningClass
export interface DerivedCombiningClass {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const DERIVED_COMBINING_CLASS_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedDecompositionType
export interface DerivedDecompositionType {
  type_name: string; // The name of the type as defined in the Unicode data file.
}

export const DERIVED_DECOMPOSITION_TYPE_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedEastAsianWidth
export interface DerivedEastAsianWidth {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const DERIVED_EAST_ASIAN_WIDTH_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedGeneralCategory
export interface DerivedGeneralCategory {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const DERIVED_GENERAL_CATEGORY_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedJoiningGroup
export interface DerivedJoiningGroup {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const DERIVED_JOINING_GROUP_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedJoiningType
export interface DerivedJoiningType {
  type_name: string; // The name of the type as defined in the Unicode data file.
}

export const DERIVED_JOINING_TYPE_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedLineBreak
export interface DerivedLineBreak {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const DERIVED_LINE_BREAK_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedName
export interface DerivedName {
  code_point: string; // Unicode code point value or range of code point values
  name_property: string; // Name property value or pattern derived from the code point
}

export const DERIVED_NAME_FIELDS = [
  "code_point",
  "name_property"
];

// #endregion

// #region DerivedNumericType
export interface DerivedNumericType {
  type_name: string; // The name of the derived numeric type as specified in the Unicode data file.
}

export const DERIVED_NUMERIC_TYPE_FIELDS = [
  "type_name"
];

// #endregion

// #region DerivedNumericValues
export interface DerivedNumericValues {
  type_name: string; // The name of the type as specified in the Unicode data file.
}

export const DERIVED_NUMERIC_VALUES_FIELDS = [
  "type_name"
];

// #endregion

// #region emoji-data
export interface EmojiData {
  codepoint: string; // The code point(s) of the emoji, represented in hexadecimal form.
  property: string; // The property associated with the emoji.
  comments: string; // Additional comments or notes regarding the emoji.
}

export const EMOJI_DATA_FIELDS = [
  "codepoint",
  "property",
  "comments"
];

// #endregion

// #region emoji-variation-sequences
export interface EmojiVariationSequences {
  type_name: string; // The name of the type as specified in the document.
}

export const EMOJI_VARIATION_SEQUENCES_FIELDS = [
  "type_name"
];

// #endregion

// #region GraphemeBreakProperty
export interface GraphemeBreakProperty {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
  joining_type: "R" | "L" | "D" | "C" | "U" | "T"; // Defines the joining type (R = Right_Joining, L = Left_Joining, D = Dual_Joining, C = Join_Causing, U = Non_Joining, T = Transparent)
  joining_group: string; // Defines the joining group, based schematically on character names
}

export const GRAPHEME_BREAK_PROPERTY_FIELDS = [
  "code_point",
  "name",
  "joining_type",
  "joining_group"
];

// #endregion

// #region SentenceBreakProperty
export interface SentenceBreakProperty {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
  joining_type: "R" | "L" | "D" | "C" | "U" | "T"; // Defines the joining type (R = Right_Joining, L = Left_Joining, D = Dual_Joining, C = Join_Causing, U = Non_Joining, T = Transparent)
  joining_group: string; // Defines the joining group, based schematically on character names
}

export const SENTENCE_BREAK_PROPERTY_FIELDS = [
  "code_point",
  "name",
  "joining_type",
  "joining_group"
];

// #endregion

// #region WordBreakProperty
export interface WordBreakProperty {
  code_point: string; // The code point of a character, in hexadecimal form
  name: string; // A short schematic name for the character
  joining_type: "R" | "L" | "D" | "C" | "U" | "T"; // Defines the joining type (R = Right_Joining, L = Left_Joining, D = Dual_Joining, C = Join_Causing, U = Non_Joining, T = Transparent)
  joining_group: string; // Defines the joining group, based schematically on character names
}

export const WORD_BREAK_PROPERTY_FIELDS = [
  "code_point",
  "name",
  "joining_type",
  "joining_group"
];

// #endregion
