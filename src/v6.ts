// This file is generated by ucd codegen. Do not edit this file directly.
// Unicode Version: 6

//#region data-files/v6.0.0/ArabicShaping.txt
/**
 * This interface defines the shaping classes for Arabic, Syriac, and N'Ko positional shaping.
 * Each character has a code point, a schematic name, a joining type, and a joining group.
 */
export interface ArabicShaping {
    /**
     * The code point, in 4-digit hexadecimal form, of an Arabic, Syriac, or N'Ko character.
     * Example: '0629'
     */
    code_point: string;

    /**
     * A short schematic name for that character, abbreviated from the normative Unicode character name.
     * This is considered a comment and does not constitute a formal property value.
     * Example: 'TEH MARBUTA'
     */
    schematic_name: string;

    /**
     * Defines the joining type of the character.
     * Possible values include:
     * - "R" for Right_Joining
     * - "L" for Left_Joining
     * - "D" for Dual_Joining
     * - "C" for Join_Causing
     * - "U" for Non_Joining
     * - "T" for Transparent
     * Example: 'R'
     */
    joining_type: "R" | "L" | "D" | "C" | "U" | "T";

    /**
     * Defines the joining group of the character, based on schematic character names.
     * The formal value consists of name parts joined by underscores.
     * Example: 'Teh_Marbuta'
     */
    joining_group: string;
}

export const ARABIC_SHAPING_FIELDS = [
    "code_point",
    "schematic_name",
    "joining_type",
    "joining_group"
];
//#endregion

//#region data-files/v6.0.0/BidiMirroring.txt
/**
 * This interface represents the Bidi_Mirroring_Glyph property mappings.
 */
export interface BidiMirroring {
    /**
     * The code point of the original character represented as a hexadecimal value.
     * Example: '0041' for 'A'.
     */
    original_code_point: string;

    /**
     * The code point of the mirrored character represented as a hexadecimal value.
     * Example: '0061' for 'a' which is the mirror of 'A'.
     */
    mirrored_code_point: string;
}

export const BIDI_MIRRORING_FIELDS = [
    "original_code_point",
    "mirrored_code_point"
];
//#endregion

//#region data-files/v6.0.0/BidiTest.txt
/**
 * Interface representing the BidiTest data structure for Unicode Bidi Algorithm conformance testing.
 */
export interface BidiTest {
    /**
     * An ordered space-delimited list of numbers indicating the resulting levels for each input property value.
     * The UBA does not assign levels to certain values; those are indicated with an 'x'.
     * Example: "1 0" or "x 1 x 2"
     */
    levels: string;

    /**
     * An ordered space-delimited list of numbers indicating the resulting visual ordering from left to right.
     * The numbers are zero-based indexes into the input string. Items with a level of 'x' are skipped.
     * Example: "1 0" or "3 1"
     */
    reorder: string;

    /**
     * An ordered list of BIDI property values.
     */
    input: string;

    /**
     * A hex bitset for paragraph levels (P):
     * 1 = auto-LTR, 2 = LTR, 4 = RTL.
     * Auto-LTR uses the first L/R/AL character, and is LTR if none is found.
     * Example: "7"
     */
    bitset: string;
}

export const BIDI_TEST_FIELDS = [
    "levels",
    "reorder",
    "input",
    "bitset"
];
//#endregion

//#region data-files/v6.0.0/Blocks.txt
/**
 * Interface representing Unicode character blocks.
 */
export interface Blocks {
    /**
     * The starting code point of the block.
     * Format: U+XXXX (e.g., U+0041 for 'A')
     */
    start_code: string;

    /**
     * The ending code point of the block.
     * Format: U+XXXX (e.g., U+007A for 'z')
     */
    end_code: string;

    /**
     * The name of the block.
     * Note: Casing is not normative (e.g., "Basic Latin" is equivalent to "BASIC LATIN").
     */
    block_name: string;
}

export const BLOCKS_FIELDS = ["start_code", "end_code", "block_name"];
//#endregion

//#region data-files/v6.0.0/CJKRadicals.txt
/**
 * Interface representing the mapping from radical numbers to CJK characters.
 */
export interface CJKRadicals {
    /**
     * The radical number, which matches the regular expression [0-9]{1,3}'?.
     * Example: "1", "2'"
     */
    radical_number: string;

    /**
     * The CJK Radical character corresponding to the radical number.
     * Example: "亻"
     */
    cjk_radical_character: string;

    /**
     * The CJK Unified Ideograph formed from the radical.
     * Example: "人"
     */
    cjk_unified_ideograph: string;
}

export const CJK_RADICALS_FIELDS = [
    "radical_number",
    "cjk_radical_character",
    "cjk_unified_ideograph"
];
//#endregion

//#region data-files/v6.0.0/CaseFolding.txt
/**
 * This interface represents the case folding properties as defined in the Unicode Character Database.
 */
export interface CaseFolding {
    /**
     * The Unicode code point of the character.
     * Format: Hexadecimal (e.g., U+0041 for 'A').
     */
    code: string;

    /**
     * The status of the case folding mapping.
     * Possible values: "C" (common), "F" (full), "S" (simple), "T" (Turkic special case).
     */
    status: "C" | "F" | "S" | "T";

    /**
     * The mapping for the case folding.
     * Format: A string of characters, separated by spaces for full mappings.
     */
    mapping: string;

    /**
     * The name of the character.
     * This is a descriptive name for the character (e.g., "LATIN CAPITAL LETTER A").
     */
    name: string;
}

export const CASE_FOLDING_FIELDS = [
    "code",
    "status",
    "mapping",
    "name"
];
//#endregion

//#region data-files/v6.0.0/CompositionExclusions.txt
/**
 * This interface represents the Composition Exclusion Table defined in UAX #15, Unicode Normalization Forms.
 *
 * @property {string} file_name - The name of the file containing the composition exclusions.
 * @property {string} date - The date when the file was created, formatted as YYYY-MM-DD, HH:MM:SS TZ.
 * @property {string} description - A brief description of the contents of the file.
 * @property {string} copyright - The copyright information for the file.
 * @property {string} terms_of_use - A link to the terms of use for the file.
 * @property {string} more_information - A link to more information regarding the composition exclusions.
 * @property {string} derivation - A link to the derivation of composition exclusions.
 */
export interface CompositionExclusions {
  file_name: string;
  date: string;
  description: string;
  copyright: string;
  terms_of_use: string;
  more_information: string;
  derivation: string;
}

export const COMPOSITION_EXCLUSIONS_FIELDS = [
  "file_name",
  "date",
  "description",
  "copyright",
  "terms_of_use",
  "more_information",
  "derivation"
];
//#endregion

//#region data-files/v6.0.0/DerivedAge.txt
/**
 * This interface represents the derived properties of Unicode characters, detailing when various code points were first assigned.
 */
export interface DerivedAge {
    /**
     * The date when the code point was assigned.
     * Format: YYYY-MM-DD, HH:MM:SS GMT
     * Example: "2010-10-05, 00:47:58 GMT"
     */
    assigned_date: string;

    /**
     * The version of Unicode when the code point was assigned.
     * Format: Major.Minor.Patch
     * Example: "1.1.0"
     */
    unicode_version: string;

    /**
     * Indicates the type of code point assigned.
     * Possible values: "graphic", "format", "control", "private-use", "surrogate", "noncharacter"
     */
    code_point_type: "graphic" | "format" | "control" | "private-use" | "surrogate" | "noncharacter";

    /**
     * Additional notes regarding the assignment of the code point.
     * Example: "The term 'assigned' means that a previously reserved code point was assigned to be a character."
     */
    notes: string;
}

export const DERIVED_AGE_FIELDS = [
    "assigned_date",
    "unicode_version",
    "code_point_type",
    "notes"
];
//#endregion

//#region data-files/v6.0.0/DerivedCoreProperties.txt
/**
 * Interface representing the properties of the Unicode Character Database.
 */
export interface DerivedCoreProperties {
    /**
     * The Unicode character's general category.
     * Example: "Lu" for uppercase letter.
     */
    general_category: "Lu" | "Ll" | "Lt" | "Lm" | "Lo" | "Mn" | "Mc" | "Me" | "Nd" | "Nl" | "No" | "Pc" | "Pd" | "Ps" | "Pe" | "Pi" | "Pf" | "Po" | "Sm" | "Sc" | "Sk" | "So" | "Zs" | "Zl" | "Zp";

    /**
     * The Unicode character's script.
     * Example: "Latn" for Latin script.
     */
    script: string;

    /**
     * The Unicode character's numeric value, if applicable.
     * Example: "1.0" for the character '1'.
     */
    numeric_value?: string;

    /**
     * The Unicode character's bidirectional category.
     * Example: "L" for left-to-right.
     */
    bidi_category: "L" | "R" | "AL" | "EN" | "ES" | "ET" | "AN" | "CS" | "NSM" | "B";

    /**
     * The Unicode character's combining class.
     * Example: "0" for a base character.
     */
    combining_class: number;

    /**
     * The Unicode character's decimal digit value, if applicable.
     * Example: "1" for the character '1'.
     */
    decimal_digit_value?: number;

    /**
     * The Unicode character's mirrored property.
     * Example: "N" for not mirrored.
     */
    mirrored: "Y" | "N";

    /**
     * The Unicode character's uppercase mapping.
     * Example: "A" for the character 'a'.
     */
    uppercase_mapping?: string;

    /**
     * The Unicode character's lowercase mapping.
     * Example: "a" for the character 'A'.
     */
    lowercase_mapping?: string;

    /**
     * The Unicode character's titlecase mapping.
     * Example: "A" for the character 'a'.
     */
    titlecase_mapping?: string;
}

export const DERIVED_CORE_PROPERTIES_FIELDS = [
    "general_category",
    "script",
    "numeric_value",
    "bidi_category",
    "combining_class",
    "decimal_digit_value",
    "mirrored",
    "uppercase_mapping",
    "lowercase_mapping",
    "titlecase_mapping"
];
//#endregion

//#region data-files/v6.0.0/DerivedNormalizationProps.txt
/**
 * Interface representing the properties of DerivedNormalization.
 */
export interface DerivedNormalization {
    /**
     * The Unicode character that is being normalized.
     * Example: "U+0041" for the character 'A'.
     */
    unicode_character: string;

    /**
     * The normalization form applied to the character.
     * Example: "NFC", "NFD", "NFKC", "NFKD".
     */
    normalization_form: "NFC" | "NFD" | "NFKC" | "NFKD";

    /**
     * Indicates whether the normalization was successful.
     * Example: true or false.
     */
    success: boolean;

    /**
     * The timestamp of when the normalization was performed.
     * Format: YYYY-MM-DDTHH:mm:ssZ
     * Example: "2010-05-20T15:14:12Z".
     */
    timestamp: string;
}

export const DERIVED_NORMALIZATION_FIELDS = [
    "unicode_character",
    "normalization_form",
    "success",
    "timestamp"
];
//#endregion

//#region data-files/v6.0.0/EastAsianWidth.txt
/**
 * EastAsianWidth
 *
 * This interface represents the East Asian Width properties of Unicode characters.
 * Each character is associated with a Unicode value and its corresponding East Asian Width property.
 *
 * The East Asian Width property can take one of the following values:
 * - "N": Neutral
 * - "A": Ambiguous
 * - "H": Half-width
 * - "W": Full-width
 * - "F": Full-width (for compatibility)
 * - "Na": Narrow
 *
 * All code points not explicitly listed are given the value "N".
 * Unassigned code points that default to "W" include ranges in specific blocks as detailed in the documentation.
 */
export interface EastAsianWidth {
  /**
   * The Unicode value of the character.
   * Format: U+XXXX, where XXXX is a hexadecimal number representing the code point.
   */
  unicode_value: string;

  /**
   * The East Asian Width property of the character.
   * Possible values: "N", "A", "H", "W", "F", "Na".
   */
  east_asian_width: "N" | "A" | "H" | "W" | "F" | "Na";
}

export const EAST_ASIAN_WIDTH_FIELDS = [
  "unicode_value",
  "east_asian_width"
];
//#endregion

//#region data-files/v6.0.0/EmojiSources.txt
/**
 * Interface representing the mappings between Unicode code points and Shift-JIS codes for cell phone carrier symbols.
 */
export interface EmojiSources {
  /**
   * Unicode code point or sequence.
   * Example: "U+1F600"
   */
  unicode_code_point_or_sequence: string;
  /**
   * DoCoMo Shift-JIS code.
   * Example: "0xE63A"
   */
  docomo_shift_jis_code: string;
  /**
   * KDDI Shift-JIS code.
   * Example: "0xE63B"
   */
  kddi_shift_jis_code: string;
  /**
   * SoftBank Shift-JIS code.
   * Example: "0xE63C"
   */
  softbank_shift_jis_code: string;
}

export const EMOJI_SOURCES_FIELDS = [
  "unicode_code_point_or_sequence",
  "docomo_shift_jis_code",
  "kddi_shift_jis_code",
  "softbank_shift_jis_code"
];
//#endregion

//#region data-files/v6.0.0/HangulSyllableType.txt
/**
 * Interface representing the Hangul Syllable Type data.
 */
export interface HangulSyllableType {
    /**
     * The Hangul syllable type code.
     * Format: "A", "B", "C"
     * Example: "A"
     */
    code: "A" | "B" | "C";

    /**
     * The description of the syllable type.
     * Format: string
     * Example: "Type A"
     */
    description: string;

    /**
     * The Unicode value of the syllable type.
     * Format: integer
     * Example: 44032
     */
    unicode_value: number;
}

export const HANGUL_SYLLABLE_TYPE_FIELDS = [
    "code",
    "description",
    "unicode_value"
];
//#endregion

//#region data-files/v6.0.0/IndicMatraCategory.txt
/**
 * This interface defines the provisional property for Indic Matra Categories.
 * It includes the code point or range and the corresponding Indic Matra Category.
 */
export interface IndicMatraCategory {
    /**
     * The code point or code point range for the character(s).
     * Example: "U+0900" or "U+0900-U+0903"
     */
    code_point: string;

    /**
     * The Indic Matra Category for the character(s).
     * This can be one of several types of dependent vowels or viramas.
     * Example: "Dependent Vowel"
     */
    indic_matra_category: string;
}

export const INDIC_MATRA_CATEGORY_FIELDS = [
    "code_point",
    "indic_matra_category"
];
//#endregion

//#region data-files/v6.0.0/IndicSyllabicCategory.txt
/**
 * This interface defines the Indic Syllabic Category property for Unicode characters.
 *
 * The Indic Syllabic Category is an enumerated property that specifies the syllabic structure
 * and segmentation rules for Indic scripts. It is used to analyze and process Indic scripts
 * such as Devanagari, Bengali, Gurmukhi, and others.
 *
 * The following fields are defined:
 *
 * - code_point: The Unicode code point or range of code points for the character(s).
 *   Example: "U+0900" or "U+0900-U+0903"
 * - indic_syllabic_category: The category of the syllable, represented as a string.
 *   Example: "Vowel", "Consonant"
 */
export interface IndicSyllabicCategory {
  code_point: string;
  indic_syllabic_category: "Vowel" | "Consonant" | "Consonant_Cluster" | "Independent_Vowel" | "Dependent_Vowel" | "Virama";
}

export const INDIC_SYLLABIC_CATEGORY_FIELDS = [
  "code_point",
  "indic_syllabic_category"
];
//#endregion

//#region data-files/v6.0.0/Jamo.txt
/**
 * This interface defines the Jamo Short Name property.
 *
 * Each entry represents a combining jamo character that participates in the algorithmic determination of Hangul syllable character names.
 *
 * @property {string} code_point - The code point of a combining jamo character in 4-digit hexadecimal form (e.g., "1100").
 * @property {string} jamo_short_name - The Jamo Short Name as a one-, two-, or three-character ASCII string (e.g., "g", "gg").
 */
export interface Jamo {
  code_point: string;
  jamo_short_name: string;
}

export const JAMO_FIELDS = [
  "code_point",
  "jamo_short_name"
];
//#endregion

//#region data-files/v6.0.0/LineBreak.txt
/**
 * LineBreak properties for Unicode characters.
 *
 * This interface defines the line break properties associated with Unicode code points.
 * Each code point is mapped to a specific line break property, which can be either normative or informative.
 *
 * Normative values include:
 * - "BK": Break
 * - "CR": Carriage Return
 * - "LF": Line Feed
 * - "CM": Combining Mark
 * - "SG": Surrogate
 * - "GL": Glue
 * - "CB": Contingent Break
 * - "SP": Space
 * - "ZW": Zero Width
 * - "NL": Next Line
 * - "WJ": Word Joiner
 * - "JL": Japanese Line Break
 * - "JV": Japanese Line Break
 * - "JT": Japanese Line Break
 * - "H2": Hyphenation
 * - "H3": Hyphenation
 *
 * Informative values include:
 * - "XX": Unknown
 * - "OP": Open
 * - "CL": Close
 * - "CP": Close Punctuation
 * - "QU": Quote
 * - "NS": Non-Space
 * - "EX": Exclamation
 * - "SY": Symbol
 * - "IS": Infix
 * - "PR": Prefix
 * - "PO": Postfix
 * - "NU": Numeric
 * - "AL": Alphabetic
 * - "ID": Identifier
 * - "IN": Infix
 * - "HY": Hyphen
 * - "BB": Break Before
 * - "BA": Break After
 * - "SA": Soft After
 * - "AI": Ambiguous Infix
 * - "B2": Break After
 *
 * All code points not explicitly listed are assigned the value "XX".
 * Unassigned code points default to "ID" in specified ranges.
 *
 * See UAX #14: Unicode Line Breaking Algorithm for more information.
 */
export interface LineBreak {
  /** Unicode value of the character. */
  unicode_value: string;
  /** Line break property of the character. */
  line_break_property: "BK" | "CR" | "LF" | "CM" | "SG" | "GL" | "CB" | "SP" | "ZW" | "NL" | "WJ" | "JL" | "JV" | "JT" | "H2" | "H3" | "XX" | "OP" | "CL" | "CP" | "QU" | "NS" | "EX" | "SY" | "IS" | "PR" | "PO" | "NU" | "AL" | "ID" | "IN" | "HY" | "BB" | "BA" | "SA" | "AI" | "B2";
}

export const LINE_BREAK_FIELDS = ["unicode_value", "line_break_property"];

//#endregion

//#region data-files/v6.0.0/NameAliases.txt
/**
 * This interface defines the formal name aliases for Unicode characters.
 */
export interface NameAliases {
    /**
     * The code point of the Unicode character, represented in hexadecimal format.
     * Example: "U+0041" for the character 'A'.
     */
    code_point: string;

    /**
     * The alias assigned to the Unicode character.
     * Example: "LATIN CAPITAL LETTER A" for the character 'A'.
     */
    alias: string;
}

export const NAME_ALIASES_FIELDS = [
    "code_point",
    "alias"
];
//#endregion

//#region data-files/v6.0.0/NamedSequences.txt
/**
 * Interface representing the NamedSequences data structure.
 */
export interface NamedSequences {
    /**
     * The name of the sequence.
     */
    name: string;
    /**
     * The code point sequence for USI, represented as a string of space-separated values.
     * Example: "1000 1001 1002"
     */
    code_point_sequence: string;
}

export const NAMED_SEQUENCES_FIELDS = [
    "name",
    "code_point_sequence"
];
//#endregion

//#region data-files/v6.0.0/NamedSequencesProv.txt
/**
 * Interface representing the provisional named sequences from the Unicode Character Database.
 */
export interface NamedSequencesProv {
    /**
     * The name of the sequence.
     */
    name: string;
    /**
     * The code point sequence for USI, represented as a string of space-separated code points.
     * Example: "1000 1001 1002"
     */
    code_point_sequence: string;
}

export const NAMED_SEQUENCES_PROV_FIELDS = [
    "name",
    "code_point_sequence"
];
//#endregion

//#region data-files/v6.0.0/NormalizationCorrections.txt
/**
 * This interface represents the normalization corrections as defined in the Unicode Character Database.
 */
export interface NormalizationCorrections {
  /**
   * Unicode code point in hexadecimal format (e.g., U+0041 for 'A').
   */
  unicode_code_point: string;
  
  /**
   * Original erroneous decomposition of the character.
   */
  original_decomposition: string;
  
  /**
   * Corrected decomposition of the character.
   */
  corrected_decomposition: string;
  
  /**
   * Version of Unicode for which the correction was entered, in n.n.n format (e.g., 6.0.0).
   */
  unicode_version: string;
  
  /**
   * Comment indicating the Unicode Corrigendum which documents the correction.
   */
  comment: string;
}

export const NORMALIZATION_CORRECTIONS_FIELDS = [
  "unicode_code_point",
  "original_decomposition",
  "corrected_decomposition",
  "unicode_version",
  "comment"
];
//#endregion

//#region data-files/v6.0.0/NormalizationTest.txt
/**
 * Interface representing the normalization test suite as defined in the Unicode Character Database.
 */
export interface NormalizationTest {
    /**
     * Conformance rule for NFC normalization.
     * Must hold true: c2 == NFC(c1) == NFC(c2) == NFC(c3)
     * Example: If c1 is 'a', c2 must be the NFC of 'a'.
     */
    c1: string;
    /**
     * Conformance rule for NFC normalization.
     * Must hold true: c2 == NFC(c1) == NFC(c2) == NFC(c3)
     * Example: If c1 is 'a', c2 must be the NFC of 'a'.
     */
    c2: string;
    /**
     * Conformance rule for NFD normalization.
     * Must hold true: c3 == NFD(c1) == NFD(c2) == NFD(c3)
     * Example: If c1 is 'a', c3 must be the NFD of 'a'.
     */
    c3: string;
    /**
     * Conformance rule for NFKC normalization.
     * Must hold true: c4 == NFKC(c1) == NFKC(c2) == NFKC(c3) == NFKC(c4) == NFKC(c5)
     * Example: If c1 is 'a', c4 must be the NFKC of 'a'.
     */
    c4: string;
    /**
     * Conformance rule for NFKD normalization.
     * Must hold true: c5 == NFKD(c1) == NFKD(c2) == NFKD(c3) == NFKD(c4) == NFKD(c5)
     * Example: If c1 is 'a', c5 must be the NFKD of 'a'.
     */
    c5: string;
}

export const NORMALIZATION_TEST_FIELDS = [
    "c1",
    "c2",
    "c3",
    "c4",
    "c5"
];
//#endregion

//#region data-files/v6.0.0/PropList.txt
/**
 * Interface representing the Unicode Character Database properties.
 */
export interface PropList {
    /**
     * The date of the file creation in GMT format.
     * Example: "2010-08-19T00:48:28Z"
     */
    date: string;
    /**
     * The version of the PropList file.
     * Example: "6.0.0"
     */
    version: string;
    /**
     * The copyright information for the Unicode Character Database.
     * Example: "Copyright (c) 1991-2010 Unicode, Inc."
     */
    copyright: string;
    /**
     * The terms of use for the Unicode Character Database.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;
    /**
     * The documentation link for the Unicode Character Database.
     * Example: "http://www.unicode.org/reports/tr44/"
     */
    documentation: string;
}

export const PROP_LIST_FIELDS = [
    "date",
    "version",
    "copyright",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v6.0.0/PropertyAliases.txt
/**
 * This interface defines the property aliases used in the Unicode Character Database (UCD).
 *
 * The properties include:
 * - abbreviated_name: A short form of the property name.
 * - long_name: A detailed description of the property.
 * - additional_aliases: Any other names that may be used for the property.
 *
 * Note: Property value names are not unique across properties, and some property names may be the same as property value names.
 *
 * Example:
 * - abbreviated_name: "AL"
 * - long_name: "Arabic Letter"
 * - additional_aliases: ["Arabic_Letter", "ALetter"]
 */
export interface PropertyAliases {
  abbreviated_name: string;
  long_name: string;
  additional_aliases?: string[];
}

export const PROPERTY_ALIASES_FIELDS = [
  "abbreviated_name",
  "long_name",
  "additional_aliases"
];
//#endregion

//#region data-files/v6.0.0/PropertyValueAliases.txt
/**
 * This interface represents the property value aliases used in the Unicode Character Database (UCD).
 *
 * Each property value name consists of the following fields:
 * - `property`: The property for which the property value name is used.
 * - `abbreviated_name`: An abbreviated name for the property value, or 'n/a' if not available.
 * - `long_name`: A long descriptive name for the property value.
 *
 * In the case of the `ccc` property, there are additional fields:
 * - `numeric`: A numeric representation of the property value.
 * - `abbreviated`: An abbreviated name for the property value.
 * - `long`: A long descriptive name for the property value.
 *
 * Note: Property value names are not unique across properties, and some property names may be the same as property value names.
 *
 * For more information, refer to UTS #18: Unicode Regular Expressions.
 */
export interface PropertyValueAliases {
  property: string;
  abbreviated_name: "n/a" | string;
  long_name: string;
  ccc?: {
    numeric: number;
    abbreviated: string;
    long: string;
  };
}

export const PROPERTY_VALUE_ALIASES_FIELDS = [
  "property",
  "abbreviated_name",
  "long_name",
  "ccc"
];
//#endregion

//#region data-files/v6.0.0/ScriptExtensions.txt
/**
 * Interface representing the Script Extensions data.
 */
export interface ScriptExtensions {
    /**
     * The date when the data was last updated.
     * Format: YYYY-MM-DD, HH:MM:SS GMT
     * Example: "2010-08-30, 01:48:36 GMT"
     */
    date: string;

    /**
     * The copyright information for the Unicode Character Database.
     * Example: "Copyright (c) 1991-2010 Unicode, Inc."
     */
    copyright: string;

    /**
     * The terms of use for the Unicode data.
     * Example: "For terms of use, see http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;

    /**
     * The documentation link for the Unicode data.
     * Example: "For documentation, see http://www.unicode.org/reports/tr44/"
     */
    documentation: string;

    /**
     * Description of the script extensions data.
     */
    description: string;

    /**
     * The script values associated with characters, space-delimited.
     * Example: "Hang for Hangul"
     */
    script_values: string;

    /**
     * Additional information regarding the provisional nature of the data.
     */
    provisional_info: string;
}

export const SCRIPT_EXTENSIONS_FIELDS = [
    "date",
    "copyright",
    "terms_of_use",
    "documentation",
    "description",
    "script_values",
    "provisional_info"
];
//#endregion

//#region data-files/v6.0.0/Scripts.txt
/**
 * Interface representing the Unicode Character Database.
 */
export interface Scripts {
    /**
     * The date of the document in GMT format.
     * Example: "2010-08-19T00:48:47Z"
     */
    date: string;
    /**
     * The version of the scripts.
     * Example: "6.0.0"
     */
    version: string;
    /**
     * The copyright information for the Unicode Character Database.
     * Example: "Copyright (c) 1991-2010 Unicode, Inc."
     */
    copyright: string;
    /**
     * The terms of use for the Unicode Character Database.
     * Example: "For terms of use, see http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;
    /**
     * The documentation link for the Unicode Character Database.
     * Example: "For documentation, see http://www.unicode.org/reports/tr44/"
     */
    documentation: string;
}

export const SCRIPTS_FIELDS = [
    "date",
    "version",
    "copyright",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v6.0.0/SpecialCasing.txt
/**
 * This interface represents the special casing properties of Unicode characters.
 */
export interface SpecialCasing {
    /**
     * The Unicode code point of the character in hexadecimal format.
     * Example: "0041" for 'A'
     */
    code: string;

    /**
     * The lowercase mapping of the character in hexadecimal format.
     * Example: "0061" for 'a'
     */
    lower: string;

    /**
     * The titlecase mapping of the character in hexadecimal format.
     * Example: "0041" for 'A'
     */
    title: string;

    /**
     * The uppercase mapping of the character in hexadecimal format.
     * Example: "0041" for 'A'
     */
    upper: string;

    /**
     * An optional list of conditions that override the normal behavior.
     * Example: "en" for English, "Not_fr" for not French
     */
    condition_list?: string;

    /**
     * A comment providing additional information about the entry.
     */
    comment?: string;
}

export const SPECIAL_CASING_FIELDS = [
    "code",
    "lower",
    "title",
    "upper",
    "condition_list",
    "comment"
];
//#endregion

//#region data-files/v6.0.0/StandardizedVariants.txt
/**
 * Interface representing standardized variation sequences defined in the Unicode Standard.
 */
export interface StandardizedVariants {
  /**
   * The variation sequence.
   * Example: "U+E0100 U+E0101"
   */
  variation_sequence: string;

  /**
   * The description of the desired appearance.
   * Example: "This character appears as a bold version."
   */
  description: string;

  /**
   * Indicates where the appearance is only different in particular shaping environments.
   * Example: "This variant is only different in certain fonts."
   */
  shaping_environments: string;
}

export const STANDARDIZED_VARIANTS_FIELDS = [
  "variation_sequence",
  "description",
  "shaping_environments"
];
//#endregion

//#region data-files/v6.0.0/extracted/DerivedBidiClass.txt
/**
 * Interface representing the Unicode Character Database derived from DerivedBidiClass-6.0.0.txt.
 */
export interface DerivedBidiClass {
    /**
     * The character code point in hexadecimal format.
     * Example: "U+0041" for the character 'A'.
     */
    code_point: string;

    /**
     * The bidirectional class of the character.
     * Example: "L" for Left-to-Right, "R" for Right-to-Left.
     */
    bidi_class: "L" | "R" | "AL" | "EN" | "ES" | "ET" | "AN" | "CS" | "NSM" | "B" | "S" | "WS" | "ON";

    /**
     * The character itself.
     * Example: "A" for the character 'A'.
     */
    character: string;

    /**
     * The numeric value associated with the character, if applicable.
     * Example: 1 for the character '1'.
     */
    numeric_value?: number;
}

export const DERIVED_BIDI_CLASS_FIELDS = [
    "code_point",
    "bidi_class",
    "character",
    "numeric_value"
];
//#endregion

//#region data-files/v6.0.0/extracted/DerivedBinaryProperties.txt
/**
 * Interface representing the derived binary properties from the Unicode Character Database.
 */
export interface DerivedBinaryProperties {
    /**
     * The name of the property.
     * Example: "Bidi_Control"
     */
    property_name: string;
    
    /**
     * The value of the property.
     * Example: "Y"
     */
    property_value: "Y" | "N";
    
    /**
     * The description of the property.
     * Example: "Indicates whether the character is a bidirectional control character."
     */
    description: string;
}

export const DERIVED_BINARY_PROPERTIES_FIELDS = [
    "property_name",
    "property_value",
    "description"
];
//#endregion

//#region data-files/v6.0.0/extracted/DerivedCombiningClass.txt
/**
 * Interface representing the Unicode Character Database derived combining class.
 */
export interface DerivedCombiningClass {
    /**
     * The derived combining class value.
     * Example: "0"
     */
    derived_combining_class: "0" | "1" | "2" | "3" | "4" | "5" | "6";

    /**
     * The canonical combining class value.
     * Example: "0"
     */
    canonical_combining_class: "0" | "1" | "2" | "3" | "4" | "5" | "6";

    /**
     * The character value.
     * Example: "A"
     */
    character: string;

    /**
     * The description of the character.
     * Example: "Latin Capital Letter A"
     */
    description: string;
}

export const DERIVED_COMBINING_CLASS_FIELDS = [
    "derived_combining_class",
    "canonical_combining_class",
    "character",
    "description"
];
//#endregion

//#region data-files/v6.0.0/extracted/DerivedDecompositionType.txt
/**
 * Interface representing the DerivedDecompositionType.
 */
export interface DerivedDecompositionType {
    /**
     * The Unicode character.
     * Format: U+XXXX where XXXX is a hexadecimal value.
     * Example: U+0041 for 'A'.
     */
    character: string;

    /**
     * The decomposition mapping for the character.
     * Format: A string that may contain multiple characters separated by commas.
     * Example: "A, B, C".
     */
    decomposition: string;

    /**
     * The canonical combining class of the character.
     * Format: An integer value representing the class.
     * Example: 0 for base characters, 230 for combining characters.
     */
    canonical_combining_class: number;

    /**
     * The bidirectional category of the character.
     * Format: A string representing the category.
     * Example: "L" for left-to-right, "R" for right-to-left.
     */
    bidirectional_category: "L" | "R" | "AL" | "EN" | "ES" | "ET" | "AN" | "CS" | "NSM" | "B" | "S" | "WS" | "ON";

    /**
     * The script associated with the character.
     * Format: A string representing the script name.
     * Example: "Latin", "Cyrillic".
     */
    script: string;
}

export const DERIVED_DECOMPOSITION_TYPE_FIELDS = [
    "character",
    "decomposition",
    "canonical_combining_class",
    "bidirectional_category",
    "script"
];
//#endregion

//#region data-files/v6.0.0/extracted/DerivedEastAsianWidth.txt
/**
 * Interface representing the Derived East Asian Width data.
 */
export interface DerivedEastAsianWidth {
    /**
     * The character code point in hexadecimal format.
     * Example: "U+0041" for the character 'A'.
     */
    code_point: string;

    /**
     * The East Asian Width property of the character.
     * Possible values: "N", "A", "H", "W", "F", "Na".
     */
    east_asian_width: "N" | "A" | "H" | "W" | "F" | "Na";
}

export const DERIVED_EAST_ASIAN_WIDTH_FIELDS = [
    "code_point",
    "east_asian_width"
];
//#endregion

//#region data-files/v6.0.0/extracted/DerivedGeneralCategory.txt
/**
 * Interface representing the Unicode Character Database derived general category.
 */
export interface DerivedGeneralCategory {
    /**
     * The general category of the character.
     * Example: "Lu" for uppercase letters.
     */
    general_category: "Lu" | "Ll" | "Lt" | "Lm" | "Lo" | "Mn" | "Mc" | "Me" | "Nd" | "Nl" | "No" | "Pc" | "Pd" | "Ps" | "Pe" | "Pi" | "Pf" | "Po" | "Sm" | "Sc" | "Sk" | "So" | "Zs" | "Zl" | "Zp";

    /**
     * The Unicode version in which the character was introduced.
     * Example: "6.0.0"
     */
    unicode_version: string;

    /**
     * The date when the character was added to the Unicode standard.
     * Format: YYYY-MM-DD
     * Example: "2010-08-19"
     */
    date_added: string;
}

export const DERIVED_GENERAL_CATEGORY_FIELDS = [
    "general_category",
    "unicode_version",
    "date_added"
];
//#endregion

//#region data-files/v6.0.0/extracted/DerivedJoiningGroup.txt
/**
 * Interface representing the DerivedJoiningGroup data structure.
 */
export interface DerivedJoiningGroup {
    /**
     * The unique identifier for the joining group.
     * Format: string
     * Example: "A"
     */
    id: string;

    /**
     * The name of the joining group.
     * Format: string
     * Example: "Left"
     */
    name: string;

    /**
     * The type of joining group.
     * Union type: "C", "D", "L", "R"
     * Example: "L"
     */
    type: "C" | "D" | "L" | "R";

    /**
     * The characters that belong to this joining group.
     * Format: array of strings
     * Example: ["A", "B", "C"]
     */
    characters: string[];
}

export const DERIVED_JOINING_GROUP_FIELDS = [
    "id",
    "name",
    "type",
    "characters"
];
//#endregion

//#region data-files/v6.0.0/extracted/DerivedJoiningType.txt
/**
 * Interface representing the Unicode Character Database derived joining type.
 */
export interface DerivedJoiningType {
    /**
     * The character's joining type, which can be one of the following: "U", "L", "R", "D", "C", "T", "A".
     * Example: "U" for Unicode.
     */
    joining_type: "U" | "L" | "R" | "D" | "C" | "T" | "A";

    /**
     * The character's code point in hexadecimal format.
     * Example: "0041" for the character 'A'.
     */
    code_point: string;

    /**
     * The character's name as defined in the Unicode standard.
     * Example: "LATIN CAPITAL LETTER A".
     */
    character_name: string;

    /**
     * The character's directionality, which can be one of the following: "L", "R", "AL", "EN", "AN", "NSM", "B", "S", "WS", "ON".
     * Example: "L" for left-to-right.
     */
    directionality: "L" | "R" | "AL" | "EN" | "AN" | "NSM" | "B" | "S" | "WS" | "ON";

    /**
     * The character's category, which can be one of the following: "Lu", "Ll", "Lt", "Lm", "Lo", "Mn", "Mc", "Me", "Nd", "Nl", "No", "Pc", "Pd", "Ps", "Pe", "Pi", "Pf", "Po", "Sm", "Sc", "Sk", "So", "Zs", "Zl", "Zp".
     * Example: "Lu" for uppercase letters.
     */
    category: "Lu" | "Ll" | "Lt" | "Lm" | "Lo" | "Mn" | "Mc" | "Me" | "Nd" | "Nl" | "No" | "Pc" | "Pd" | "Ps" | "Pe" | "Pi" | "Pf" | "Po" | "Sm" | "Sc" | "Sk" | "So" | "Zs" | "Zl" | "Zp";
}

export const DERIVED_JOINING_TYPE_FIELDS = [
    "joining_type",
    "code_point",
    "character_name",
    "directionality",
    "category"
];
//#endregion

//#region data-files/v6.0.0/extracted/DerivedLineBreak.txt
/**
 * Interface representing the Unicode Character Database derived line break properties.
 */
export interface DerivedLineBreak {
    /**
     * The date of the file creation in ISO 8601 format.
     * Example: "2010-08-19T00:48:10Z"
     */
    date: string;

    /**
     * The version of the derived line break properties.
     * Example: "6.0.0"
     */
    version: string;

    /**
     * The copyright information for the Unicode Character Database.
     * Example: "Copyright (c) 1991-2010 Unicode, Inc."
     */
    copyright: string;

    /**
     * The terms of use for the Unicode Character Database.
     * Example: "For terms of use, see http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;

    /**
     * The documentation link for the Unicode Character Database.
     * Example: "For documentation, see http://www.unicode.org/reports/tr44/"
     */
    documentation: string;
}

export const DERIVED_LINE_BREAK_FIELDS = [
    "date",
    "version",
    "copyright",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v6.0.0/extracted/DerivedNumericType.txt
/**
 * Interface representing the DerivedNumericType from the Unicode Character Database.
 */
export interface DerivedNumericType {
    /**
     * The numeric value associated with the character.
     * Example: "1.0"
     */
    numeric_value: "string";
    
    /**
     * The numeric type of the character.
     * Example: "decimal"
     */
    numeric_type: "string";
    
    /**
     * The character that this numeric value is associated with.
     * Example: "U+0031" for the character '1'
     */
    character: "string";
}

export const DERIVED_NUMERIC_TYPE_FIELDS = [
    "numeric_value",
    "numeric_type",
    "character"
];
//#endregion

//#region data-files/v6.0.0/extracted/DerivedNumericValues.txt
/**
 * Interface representing the derived numeric values from the Unicode Character Database.
 */
export interface DerivedNumericValues {
    /**
     * The numeric value associated with a character.
     * Example: "1.0"
     */
    numeric_value: "string";
    
    /**
     * The type of numeric value.
     * Example: "decimal"
     */
    numeric_type: "string";
    
    /**
     * The source of the numeric value.
     * Example: "Unicode"
     */
    source: "string";
}

export const DERIVED_NUMERIC_VALUES_FIELDS = [
    "numeric_value",
    "numeric_type",
    "source"
];
//#endregion

//#region data-files/v6.0.0/auxiliary/GraphemeBreakProperty.txt
/**
 * Interface representing the Grapheme Break Property data.
 */
export interface GraphemeBreakProperty {
    /**
     * The character that represents the grapheme break property.
     * Example: "CR" for Carriage Return.
     */
    character: string;

    /**
     * The Unicode code point of the character.
     * Example: 0x0A for Line Feed.
     */
    code_point: number;

    /**
     * The grapheme break property value associated with the character.
     * Example: "Grapheme_Cluster_Break" for characters that break grapheme clusters.
     */
    property_value: "Grapheme_Cluster_Break" | "Other" | "Control";
}

export const GRAPHEME_BREAK_PROPERTY_FIELDS = [
    "character",
    "code_point",
    "property_value"
];
//#endregion

//#region data-files/v6.0.0/auxiliary/GraphemeBreakTest.txt
/**
 * Interface representing the Grapheme Break Test data.
 */
export interface GraphemeBreakTest {
    /**
     * A string containing hex Unicode code points.
     * Example: "U+0041 U+0042"
     */
    code_points: string;
    /**
     * An optional comment associated with the code points.
     * Example: "# This is a comment"
     */
    comment?: string;
}

export const GRAPHEME_BREAK_TEST_FIELDS = [
    "code_points",
    "comment"
];
//#endregion

//#region data-files/v6.0.0/auxiliary/LineBreakTest.txt
/**
 * Default Line Break Test
 */
export interface LineBreakTest {
    /**
     * Date of the test in GMT format.
     * Example: "2010-08-30, 21:08:43 GMT"
     */
    date: string;
    /**
     * Contains hex Unicode code points.
     * Example: "U+0041 U+0042"
     */
    unicode_character_database: string;
    /**
     * Copyright information.
     * Example: "Copyright (c) 1991-2010 Unicode, Inc."
     */
    copyright: string;
    /**
     * Terms of use URL.
     * Example: "http://www.unicode.org/terms_of_use.html"
     */
    terms_of_use: string;
    /**
     * Documentation URL.
     * Example: "http://www.unicode.org/reports/tr44/"
     */
    documentation: string;
}

export const LINE_BREAK_TEST_FIELDS = [
    "date",
    "unicode_character_database",
    "copyright",
    "terms_of_use",
    "documentation"
];
//#endregion

//#region data-files/v6.0.0/auxiliary/SentenceBreakProperty.txt
/**
 * Interface representing the properties related to sentence breaking as defined in the Unicode Character Database.
 */
export interface SentenceBreakProperty {
    /**
     * The character that indicates a sentence break.
     * Example: '\n' for a newline character.
     */
    break_character: string;

    /**
     * The type of sentence break.
     * Example: "CR" for carriage return, "LF" for line feed.
     */
    break_type: "CR" | "LF" | "NL" | "SP";

    /**
     * Indicates whether the character is a sentence terminator.
     * Example: true for '.', '!', '?' characters.
     */
    is_terminator: boolean;

    /**
     * The Unicode code point of the character.
     * Example: 46 for '.' (dot).
     */
    code_point: number;

    /**
     * The language or locale associated with the sentence break property.
     * Example: "en" for English, "fr" for French.
     */
    language: string;
}

export const SENTENCE_BREAK_PROPERTY_FIELDS = [
    "break_character",
    "break_type",
    "is_terminator",
    "code_point",
    "language"
];
//#endregion

//#region data-files/v6.0.0/auxiliary/SentenceBreakTest.txt
/**
 * Default Sentence Break Test
 *
 * Format:
 * <string> (# <comment>)? 
 * <string> contains hex Unicode code points, with
 */
export interface SentenceBreakTest {
  /**
   * The string containing hex Unicode code points.
   * Example: "0041 0042 0043"
   */
  string: string;
  /**
   * An optional comment associated with the string.
   * Example: "This is a comment"
   */
  comment?: string;
}

export const SENTENCE_BREAK_TEST_FIELDS = [
  "string",
  "comment"
];
//#endregion

//#region data-files/v6.0.0/auxiliary/WordBreakProperty.txt
/**
 * Interface representing the WordBreakProperty.
 */
export interface WordBreakProperty {
    /**
     * The word break property value.
     * 
     * This property can take one of the following values: "normal", "break-all", "keep-all", "break-word".
     * Example: "normal"
     */
    word_break: "normal" | "break-all" | "keep-all" | "break-word";
}

export const WORD_BREAK_PROPERTY_FIELDS = [
    "word_break"
];
//#endregion

//#region data-files/v6.0.0/auxiliary/WordBreakTest.txt
/**
 * Interface representing the Word Break Test data.
 */
export interface WordBreakTest {
    /**
     * A string containing hex Unicode code points.
     * Example: "0041 0042 0043"
     */
    string: string;

    /**
     * An optional comment associated with the string.
     * Example: "# This is a comment"
     */
    comment?: string;
}

export const WORD_BREAK_TEST_FIELDS = [
    "string",
    "comment"
];
//#endregion

